# 绪论

数据结构：相互之间存在一种或多种特定关系的数据元素的集合

按照视点的不同，我们吧数据结构分为逻辑结构和物理结构

## 逻辑结构和物理结构

### 逻辑结构

逻辑结构：数据对象中数据元素之间的相互关系。它是针对某个具体问题选择的数据结构，表示了数据元素之间的逻辑关系

可以分为以下几种：

* 集合结构：集合结构中的数据元素除了同属于一个集合外，它们之间没有其他关系。各数据元素是平等的，类似于数学中的集合。

![QQ图片20221231110109](QQ图片20221231110109.png)

* 线性结构：线性结构中的数据元素之间是一对一的关系。

![QQ图片20221231110259](QQ图片20221231110259.png)

* 树形结构：树形结构中的数据元素之间存在一对多的层次关系

![QQ图片20221231110457](QQ图片20221231110457.png)

* 图形结构：图形结构的数据元素是多对多的关系

![QQ图片20221231110602](QQ图片20221231110602.png)

### 物理结构

物理结构又叫存储结构，指数据的逻辑结构在计算机中的存储形式

数据元素的存储结构形式有两种：顺序存储和链式存储

* 顺序存储结构：把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的

![QQ图片20221231111128](QQ图片20221231111128.png)

* 链式存储结构：把数据元素存放在任意的存储单元中，这组存储单元可以是连续的，也可以是不连续的。需要用一个指针存放数据元素的地址，这样就可以通过地址找到相关联数据元素的位置

![QQ图片20221231111646](QQ图片20221231111646.png)

链表和数组对应计算机世界的两种基本访问方式：顺序访问和随机访问

链表和数组对比，链表的插入速度和删除速度更快，但是这有一个前提：已知插入元素或者要删除的元素的位置。

## 算法的定义

算法：它是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，每条指令表示一个或多个操作

算法的几个基本特性：

* 输入：算法具有零个或多个输入
* 输出：算法至少有一个或多个输出
* 有穷性：算法在执行有限的步骤之后自动结束
* 确定性：算法的每一步都具有确定的含义，不会出现二义性
* 可行性：算法的每一步都必须是可行的，每一步都能通过执行有限次数完成。可行性意味着算法可以转换为程序运行。

好的算法的特征：

* 正确性：一个算法的正确性通常都是用数学方法证明的，因为很难穷尽所有的测试场景。一般情况下，算法能处理合法输入，对非法输入产生合理的输出，就可以说它是一个正确的算法了
* 可读性
* 健壮性：当输入数据不合法时，算法也能作出相关处理，而不是产生异常或者莫名其妙的结果
* 时间效率高和存储量低

## 算法效率的度量方法

一般分为两大类：事后统计方法和事前分析估算方法

事后统计方法：通过设计好的测试程序和数据，对不同算法编制的程序运行时间进行比较，从而确定算法效率高低

这种方法的缺点：

* 编制测试程序和准备数据需要花费大量时间和精力
* 程序运行时间取决于多个因素，与硬件、操作系统、编译器、计算机当时的CPU和内存、存储情况都有关，这些因素有时会掩盖算法本身的优劣
* 程序运行时间和测试数据有关，用什么样的测试数据来测试很难判断

事前分析估算方法：在编写程序前，依据统计方法对算法进行估算

抛开与计算机硬件、软件有关的因素，一个程序的运行时间，依赖于算法的好坏和问题的输入规模。

分析一个算法的运行时间时，重要的是把基本操作的数量与输入规模关联起来。

由于函数的渐进增长特性，我们总是可以在n比较大的时候，区分出算法效率的高低。函数的渐进增长：给定两个函数fn和gn，如果存在一个整数N，使得对于所有n>N，fn总是比gn大，那么就称fn的增长渐进快于gn

## 大O表示法

在进行算法分析时，语句总的操作数T(n)是关于问题规模n的函数，算法的时间复杂度记作T(n)=O(f(n))，随着问题规模n增大，f(n)的增长率和算法执行时间的增长率相同，它被称为算法的渐进时间复杂度，简称为时间复杂度。

大O表示法是一种表示算法速度的表示法。大O表示法指的并非是算法执行的具体时间，而是操作数随着元素数量增长的增速，它指出了算法运行时间的增速。例如对于查找算法来说：

当元素数量少的时候，简单查找和二分查找耗时是差不多的，但当元素数量急速上涨时：

* 简单查找：元素增加10亿个，操作数有10亿个
* 二分查找：元素增加10亿个，操作数只有30个

O(n)中n代表操作数，例如查找长度为n的列表，二分查找需要执行logn次操作，而简单查找需要执行n次操作。

大O表示法指出了最糟糕情况下的运行时间（除非特别指定，提到的运行时间都是最坏情况的运行时间），例如简单查找时也有可能查一次就找到了，但最糟糕的情况下需要查找n次。

常见的大O运行时间：

* O(logn)：对数时间，如二分查找（用大O表示法来讨论运行时间时，log指的都是log2，是以2为底的）
* O(n)：线性时间，如简单查找
* O(nlogn)：如快速排序
* O(n2)：平方时间，如选择排序
* O(n!)：如旅行商问题

有时会遇到算法的运行速度不稳定的情况，例如快速排序法的运行速度取决于如何选择其基准值，基准值选的好（例如每次随机选一个位置），递归次数就少；选的不好（选了最大值或者最小值），可能要递归很多次。所以描述快速排序的时间复杂度时，要说明在最遭情况下其运行时间为O(n2)，在平均情况下，其运行时间为O(nlogn)

对于两个复杂度相同的算法，如快速排序和合并排序，它们的运行时间差异关键是算法所需的固定时间量，它被称为常量，也就是一个操作数真正的运行时间，O(n)实际上是O(cn)，其中c就是每个算法固定的时间量，不同的算法c的大小不同。但是通常c被忽略不计，因为如果两种算法的大O运行时间不同，这种常量将无关紧要。因为快速排序的c值小于合并排序的c值，所以快速排序更快。

## NP完全问题和贪婪算法

旅行商问题：一个旅行商需要前往n个城市，为了保证旅程最短，他需要规划前往这些城市的先后顺序。当穷举这些路线时，可以发现一共有n!种路线。找到路线中最短的一条，需要O(n!)。像这种需要计算所有的解，并从中选出最小的那个，就属于NP完全问题，它可以用一种近似算法来解决，例如随机选择出发城市，然后此后的每一步都选择离自己最近的没去过的城市。

另一个典型的NP完全问题：集合覆盖问题。建立一个球队，每个候选球员都有自己一些素质：如擅长雨中作战、奔跑。每个球员又有不同的作用，如后卫，这些位置和前面的素质有对应关系。在人数有限的情况下，组建一个最优的球队，这就是集合覆盖问题。

![QQ图片20230114103819](QQ图片20230114103819.png)

可以按照前面的近似算法来组建球队，首先找到符合要求最多的球员，然后给他安排位置，不断重复这个过程，直到球队满足要求。

再来介绍一个集合覆盖问题：假如办了一个广播节目，需要让所有州的听众都收听的到，为此需要决定在哪些广播台播出，在每个广播台播出都需要支付费用，因此选择尽量少的广播台播出。每个广播台否覆盖特定的区域，不同广播台覆盖的区域可能是重叠的：

![QQ图片20230114104321](QQ图片20230114104321.png)

找出覆盖全部区域的最小广播台集合，为了解决这个问题，需要列出每个可能的广播台集合，有2的n次方个，然后在这些集合中，筛选可覆盖所有区域的最小集合。一个近似算法是：选出一个广播台，它覆盖了最多的未覆盖区域，然后重复这一步，直到所有区域被覆盖。

NP完全问题的特点：

- 随着元素数量增加，速度会变得非常慢
- 涉及到所有的组合
- 不能将问题分成小问题，必须考虑所有可能的情况
- 通常涉及序列、集合，如果可以将问题转化为旅行商问题或集合覆盖问题，那它就是NP完全问题

上面介绍的近似算法也有一个名字：贪婪算法，它简单易行，每步都采取最优的做法，采取局部最优解，它可能最终会得到全局最优解，此时它就是准确的算法；但有时它也得不到全局最优解，但可为一些复杂的问题提供简单快捷的近似算法。

## 算法空间复杂度

算法的空间复杂度是计算算法所需要的存储空间，计算公式记作S(n)=O(f(n))，其中n为问题的规模，f(n)为n所占存储空间的函数。

当单纯说复杂度的时候，一般说的是时间复杂度。

# 线性表

## 定义

线性表：0个或者多个数据元素的有限序列

几个关键点：

* 序列：元素之前是有顺序的，每个元素都有它的前驱或者后继（除了第一个元素和最后一个元素）
* 有限：元素数量是有限的

线性表一般有多种实现方式：

* 顺序存储结构，例如数组
* 链式存储结构，例如链表

## 数组

### 自定义ArraysList

下面是自定义实现的一个ArraysList，实现的方法有：空参构造、clear、size、isEmpty、trimToSize、get、set、ensureCapacity、add、remove、iterator

~~~java
class MyArraysList implements Iterable<Object>{

	//表的底层实现数组
	private Object[] array;
	//一个常量，指示数组初始化时的大小
	private static final int DEFAULT = 10;
	//这个变量指示表的实际大小
	private int theSize = 0;
	
	public boolean isEmpty(){
		return size() == 0;
	}
	
	//修剪工作实际上是通过重设大小完成的
	public void trimToSize(){
		ensureCapacity(size());
	}
	
	//表的初始化实际上就是设置数组的默认大小
	public MyArraysList() {
		super();
		doclear();
	}

	private void doclear() {
		theSize = 0;
		ensureCapacity(DEFAULT);
	}

	private void ensureCapacity(int newCapacity) {
		
		//如果重设大小会导致数据损失则操作无效
		if(size() > newCapacity){
			return;
		}
		
		//重设大小会把原数组的索引赋给另一个对象
		//新建一个对应大小的数组并完成数组的拷贝
		Object[] old = array;
		array = new Object[newCapacity];
		for(int i = 0 ;i < size();i++){
			array[i] = old [i];
		}
	}

	private int size() {
		
		return theSize;
	}
	
	public Object get(int index){
		if(index >= size() || index < 0){
			//数组越界异常
			throw new ArrayIndexOutOfBoundsException();
		}
		
		return array[index];
	}
	
	public Object set(int index ,Object value){
		if(index >= size() || index < 0){
			//数组越界异常
			throw new ArrayIndexOutOfBoundsException();
		}
		
		Object oldValue = array[index];
		array[index] = value;
		//set返回的是赋值前的值
		return oldValue;
	}

	//两种添加操作实际上都通过一个更常规的add来完成
	public void add(Object value){
		add(size(),value);
	}
	
	public void add(int index, Object value) {
		//如果数组的大小与表的大小一致说明没有足够的空间来插入
		//此时就要完成数组的扩充
		if(array.length == size()){
			ensureCapacity(2 * size() + 1);
		}
		
		//Object[] old = array;
		//array = new Object[old.length+1];
		//无需创建另一个对象完成索引的传递
		//在一次循环中就可以完成插入工作
		//未涉及的部分数据不变
		for(int i = size();i > index;i--){
			array[i] = array[i-1];
		}
		//要插入的部分单独赋值
		array[index] = value;
		//每次插入表的大小都会加1
		theSize++;
	}
	
	public Object remove(int index){
		
		//remove返回的是除掉的元素值
		//故在索引改变前拿到该值
		Object del = array[index];
		//无需创建其他对象在一次循环中即可完成位置转换
		for(int i = index;i < size() - 1;i++){
			array[i] = array[i+1];
		}
		//每次插入表的大小都会减1
		theSize--;
		//返回除掉的元素值
		return del;
	}
  
  	//实现迭代器的第二种方法：嵌套类 private static class；还有一种是非静态的内部类，区别不大
	public Iterator<Object> iterator(){
		return new MyArraysListIterator(this);
	}
	
	private static class MyArraysListIterator implements Iterator<Object>{

		//嵌套类有自己的域
		//通过有参构造成功得到表的引用
		private MyArraysList list;
		//用这个变量指示迭代器的位置
		private int current_index = 0;

		//通过空参构造成功得到表的引用
		public MyArraysListIterator(MyArraysList myArraysList) {
			list = myArraysList;
		}

		@Override
		public boolean hasNext() {
			
			return current_index < list.size();
		}

		@Override
		public Object next() {
			if(!hasNext()){
				throw new NoSuchElementException();
			}
			//虽然array是私有的，但因为嵌套类还是本类的一部分
			//所以还是可以访问
			return list.array[current_index++];
		}

		@Override
		public void remove() {
			//通常来说执行完next再执行remove就会删除该元素
			//此时需要把位置减一再调用表的remove方法
			list.remove(--current_index);
		}
		
	}
}
~~~

### 回字打印矩阵

~~~java
	//回字形打印矩阵，这里用的方法是拆成子问题，然后逐个解决子问题，这种思路写代码的速度最快
	//在第一个方法中，定义了四个值分别作为每轮打印的左上角坐标和右下角坐标
	//每轮打印一圈，然后各坐标变化后继续打印
	
	//在第二个方法中，先处理两个坐标重合的情况，这种情况下只打印一个数
	//再处理头尾结点坐标行相同或列相同的情况
	//最后处理四个值各不相同的情况
	public static void printMatrix(int a[][]){
		int column = a.length - 1;
		int row = a[0].length - 1;
		int n = 0;
		int m = 0;
		while(n <= column && m <= row){
			printMatrix(a, n++, m++, column--, row--);
		}
	}
	
	private static void printMatrix(int[][] a, int n, int m, int column, int row){
		if(n == column && m == row){
			System.out.println(a[n][m]);
		}else if(m == row){
			while(n <= column){
				System.out.println(a[n++][m]);
			}
		}else if(n == column){
			while(m <= row){
				System.out.println(a[n][m++]);
			}
		}else{
			int beginColumn = n, beginRow = m;
			while(m < row){
				System.out.println(a[n][m++]);
			}
			while(n < column){
				System.out.println(a[n++][row]);
			}
			while(beginRow < row){
				System.out.println(a[column][row--]);
			}
			while(beginColumn < column){
				System.out.println(a[column--][beginRow]);
			}
		}
	}
~~~

### 旋转矩阵

顺时针旋转正方形矩阵：

~~~java
	//顺时针旋转正方形矩阵
	//解决问题的思路还是分解成小问题，一圈一圈解决
	//定义了一圈的左上角点坐标和右下角坐标
	//对于特定的一圈而言，如果只有一个数那么就无需调整位置
	//对于普通情况，只需制造一个循环，每次循环调整4个数的位置，先写好调整四个角的，然后调整即可
	public static void clockWisePrint(int[][] arr){
		int n = 0, m = 0;
		int column = arr.length - 1;
		int row = arr[0].length - 1;
		while(n <= column && m <= row){
			clockWisePrint(arr, n++, m++, column--, row--);
		}
	}
	
	private static void clockWisePrint(int[][] arr, int n, int m, int column, int row){
		if(n == column){
			return;
		}else{
			int t , i = 0;
			while(i < (column - n)){
				t = arr[n][m + i];
				arr[n][m + i] = arr[column - i][m];
				arr[column - i][m] = arr[column][row - i];
				arr[column][row - i] = arr[n + i][row];
				arr[n + i][row] = t;
				i++;
			}
		}
	}
~~~

### 之子打印矩阵

之字形打印一个矩阵，例如：

[1, 2, 3, 4]
[5, 6, 7, 8]
[9, 10, 11, 12]
打印结果为1,2,5,9,6,3,4,7,10,11,8,12

~~~java
	//之字形打印一个矩阵
	//依然采用划分问题的思路，其实它的子问题就是已知一条斜打印线的起点和终点，如何打印这条斜线
	//这个问题通过改变下标很容易解决，而打印线的起点和终点是通过每次坐标沿着边界移动实现的
	//每次是斜向上打印还是向下打印是交替进行的，用一个布尔变量来指示这一点，每次循环完成都更新这个布尔变量
	public static void zhiPrint(int[][] arr){
		int i = 0, j = 0;
		int m = 0, n = 0;
		boolean flag = true;
		while(m <= arr.length - 1 && n <= arr[0].length - 1){
			zhiPrint(arr, flag, i, j, m, n);
			flag = !flag;
			if(j == arr[0].length - 1){
				i++;
			}else{
				j++;
			}
			
			if(m == arr.length - 1){
				n++;
			}else{
				m++;
			}
		}
	}
	
	private static void zhiPrint(int[][] arr, boolean flag, int i, int j, int m, int n){
		if(flag){
			while(i <= m && n <= j){
				System.out.println(arr[m--][n++]);
			}
		}else{
			while(i <= m && n <= j){
				System.out.println(arr[i++][j--]);
			}
		}
	}
~~~





## 链表

链表的每个结点都由两部分组成：数据域和指针域

链表的第一个结点存储位置叫头指针，整个链表的存取都必须从头指针开始：

![QQ图片20221231191305](QQ图片20221231191305.png)

头指针具有标识作用，它常常以链表的名字命名。

有时为了更加方便地对链表进行操作，会在单链表的第一个结点前附设一个结点，称为头结点，它的数据域不存储信息，有时也可以存储链表长度等信息，它的指针域就是头指针：

![QQ图片20221231191537](QQ图片20221231191537.png)

头结点不是链表的必要因素，它是为了操作的统一和方便设立的，有了头结点，对在第一元素结点前插入和删除操作，就和其他结点的操作统一了。

有些早期的编程语言由于没有指针的概念，此时可以用数组来代替指针，用两个数组来表示一个链表，一个数组用来记录数据域，另一个数组用来记录指针域。这种用数组描述的链表叫静态链表。

### 自定义LinkedList

下面是自定义实现的一个LinkedList，已经实现的：Node类、空参构造、clear、size、isEmpty、add、get、set、remove、iterator

~~~java
class MyLinkedList<AnyType> implements Iterable<AnyType>{
	
	//Node是一个嵌套类，代表链表的一个结点
	//这类中所有的成员都是public这主要因为嵌套类本身是private
	//所以外界依然对这些成员不可见
	private static class Node<AnyType>{
		//三个域分别代表一个结点的两个指针域和一个数据域
		public Node<AnyType> next;
		public Node<AnyType> pre;
		public AnyType value;
		
		//给出对应的构造方法
		public Node(AnyType value, Node<AnyType> pre, Node<AnyType> next) {
			super();
			this.next = next;
			this.pre = pre;
			this.value = value;
		}
		
	}

	//begin和end分别代表头结点 和尾结点
	private Node<AnyType> begin;
	private Node<AnyType> end;
	//theSize代表 表的实际容量
	private int theSize;
	//modCount代表修改次数，它在迭代器中结合另一个域变量
	//可以对并发修改进行限制，它是线程不安全的标志，
	//这被称之为failFast机制
	private int modCount = 0;

	//空参构造
	public MyLinkedList() {
		super();
		doclear();
	}

	public void clear(){
		doclear();
	}
	
	//初始化一个链表：只有头结点和尾结点
	//这两个结点不属于数据的一部分，它们没有数据域
	private void doclear() {
		
		begin = new Node<AnyType>(null, null, null);
		end = new Node<AnyType>(null, begin, null);
		begin.next = end;
		
		theSize = 0;
		modCount++;
		
	}

	public int size(){
		return theSize;
	}
	
	public boolean isEmpty(){
		return theSize == 0;
	}
	
	public AnyType get(int index){
		//这里重新构造了一个获得Node的get方法
		//主要是因为后来的set、remove需要用到这个方法获得Node
		return getNode(index).value;
	}
	
	private Node<AnyType> getNode(int index) {
		
		Node<AnyType> node;
		//index不合法时
		if(index >= size() || index < 0){
			//越界异常
			throw new IndexOutOfBoundsException();
		}
		
		//如果index在表中位置靠后，则从后向前搜索
		if(index * 2 > size()){
			//这个结点是有数据域的最后一个结点
			node = end.pre;
			for(int i = size() - 1;i > index;i--){
				node = node.pre;
			}
		}else{
			//如果index在表中位置靠前，则从前向后搜索
			//这个结点是有数据域的第一个结点
			node = begin.next;
			for(int i = 0;i < index;i++ ){
				node = node.next;
			}
		}
		return node;
	}

	//这里有两个add方法对外均使用
	public void add(AnyType x){
		add(size(),x);
	}
	
	public void add(int index, AnyType x) {
		
		//用getNode方法获得对应结点
		Node<AnyType> nextNode = getNode(index);
		//Node preNode = nextNode.pre;
		//构造对应的新node
		Node<AnyType> node = new Node<AnyType>(x, nextNode.pre, nextNode);
		//把前后指针域都刷新一下
		node.pre.next = node;
		node.next.pre = node;
		
		theSize++;
		modCount++;
	}

	public AnyType set(int index ,AnyType x){
		//用getNode方法获得对应结点
		Node<AnyType> node = getNode(index);
		
		//因为要返回set前的值所以新建一个变量赋予索引
		AnyType old = node.value;
		node.value = x;
		return old;
		
	}
	
	public AnyType remove(int index){
		//这里调用了一个删除结点的方法
		//原因是在迭代器里有删除结点的操作必须重载
		return remove(getNode(index));
		
	}
	private AnyType remove(Node<AnyType> node) {
		//Node<AnyType> node = getNode(index);
		//因为要返回删除前的值所以新建一个对象记录值
		AnyType old = node.value;
		//更新前后结点的指针域
		node.pre.next = node.next;
		node.next.pre = node.pre;
		//把自身的指针域去除
		node.pre = node.next = null;
		
		theSize--;
		modCount++;
		
		return old;
	}

	@Override
	public Iterator<AnyType> iterator() {
		//用嵌套类做迭代器需要传入对象
		return new MyLinkedListIterator<AnyType>(this);
	}
	
	//这是一个嵌套类
	private static class MyLinkedListIterator<AnyType> implements Iterator<AnyType>{

		//域对象传入本类对象用来完成有参构造的初始化
		private MyLinkedList<AnyType> list;
		//private int current_index = 0;
		//这里不再用int值而是用结点来指示迭代器的位置
		private Node<AnyType> currentNode = list.begin.next;
		//expectedModCount是检查并发修改的重要变量，它刚开始被初始化为modCount
		private int expectedModCount = list.modCount;
		//okToRemove变量用来指示是否有进行remove操作的权限
		private boolean okToRemove = false;
		
		//有参构造
		public MyLinkedListIterator(MyLinkedList<AnyType> list) {
			super();
			this.list = list;
		}

		//如果已经到了最后一个结点那么后面已经没有可以操作的结点了
		@Override
		public boolean hasNext() {
			return currentNode != list.end;
		}

		@Override
		public AnyType next() {
			//并发修改异常检查
			if(expectedModCount != list.modCount){
				throw new ConcurrentModificationException();
			}
			//每次用hasNext检查是否可以进行操作
			if(!hasNext()){
				throw new NoSuchElementException();
			}
			//因为要返回值且要更新索引故用一个变量记录原来的值
			AnyType value = currentNode.value;
			//向下移动一个结点
			currentNode = currentNode.next;
			//只有进行了next才能有remove的权限
			okToRemove = true;
			return value;
		}

		@Override
		public void remove() {
			//并发修改异常检查
			if(expectedModCount != list.modCount){
				throw new ConcurrentModificationException();
			}
			//remove权限检查
			if(okToRemove){
				throw new IllegalStateException();
			}
			//调用原来list的remove，此时modCount也加1
			list.remove(currentNode.pre);
			//对应的expectedModCount也必须加1
			//这样用迭代器时只有用迭代器的remove才不会抛出异常
			//同时也不允许多个迭代器共同作用
			expectedModCount++;
			//去除进行remove的权限
			okToRemove = false;
		}
	}
}
~~~

### 判断链表是否为回文结构

链表类问题时间复杂度一般都为n，优化解一般是从空间复杂度入手，一般空间复杂度为1的最优

1、第一种方法：借助一个栈来完成这个功能，首先遍历链表将所有元素装入栈中，再遍历一遍与栈中的数一一比对，如果不相等就是非回文链表。这种方法利用的就是回文链表的顺序和逆序是一样的：

~~~java
	public static boolean isHuiChain_a(Node head){
		Stack<Integer> stack =  new Stack<Integer>();
		Node currentNode = head;
		while(currentNode != null){
			stack.push(currentNode.val);
			currentNode = currentNode.next;
		}
		currentNode = head;
		while(currentNode != null){
			if(currentNode.val != stack.pop()){
				return false;
			}
			currentNode = currentNode.next;
		}
		return true;
	}
~~~

2、第二种方法：还是借助一个栈来完成功能，和上一个方法相比这个算法需要的栈的大小仅仅是链表长度的一半。设置两个指针，一个每次走两步，一个每次走一步，当走两步那个指针走完时，另一个指针正好指在中间，继续遍历的过程中，将剩余元素装入栈中，重新遍历链表，对比剩余元素，不对的话直接返回false，如果至栈为空都能对上则返回true

~~~java
	public static boolean isHuiChain_b(Node head){
		Stack<Integer> stack =  new Stack<Integer>();
		Node currentNode = head;
		Node keyNode = head;
		//走两步的指针keyNode必须保证不为空且它的next也不能为空，否则会出现空指针异常
		//链表长度为奇数则currentNode停在正中央，如果为偶数则currentNode停在中间两个结点的后一个上
		//无论是哪种情况都可以将所有信息装入栈中验证
		while(currentNode != null && keyNode != null && keyNode.next != null){
			currentNode = currentNode.next;
			keyNode = keyNode.next.next;
		}
		
		while(currentNode != null){
			stack.push(currentNode.val);
			currentNode = currentNode.next;
		}
		currentNode = head;
		while(!stack.isEmpty()){
			if(currentNode.val != stack.pop()){
				return false;
			}
			currentNode = currentNode.next;
		}
		
		return true;
	}
~~~

3、第三种方法：它不用辅助空间就能完成功能

~~~java
	//不借助辅助空间来实现功能，首先设置两个指针，一个指针一次走一步，一个一次走两步
	//最后走完时，另一个指针停在链表的正中间位置或中间两个位置的后一个
	//该指针从该位置开始讲指针反转，反转结束后：1-》2-》3《-2《-1
	//此时从两头遍历，遍历结束后还没有出现不相等情况则是回文结构
	//最后，恢复链表结构把值返回
	public static boolean isHuiChain_c(Node head){
		
		if(head.next == null){
			return true;
		}
		
		boolean flag = true;
		
		//设置两个指针，一个指针一次走一步，一个一次走两步
		Node currentNode = head;
		Node keyNode = head;
		while(currentNode != null && keyNode != null && keyNode.next != null){
			currentNode = currentNode.next;
			keyNode = keyNode.next.next;
		}
		
		//该指针从该位置开始讲指针反转，反转结束后：1-》2-》3《-2《-1
		Node preNode = null;
		Node midNode = null;
		
		while(currentNode != null){
			midNode = currentNode.next;
			currentNode.next = preNode;
			preNode = currentNode;
			currentNode = midNode;
		}
		
		//此时从两头遍历，遍历结束后还没有出现不相等情况则是回文结构
		Node endPositionNode = preNode;
		keyNode = head;
		while(keyNode!= null && preNode != null){
			if(keyNode.val != preNode.val){
				flag = false;
				break;
			}
			keyNode = keyNode.next;
			preNode = preNode.next;
		}
		
		//最后，恢复链表结构
		midNode = null;
		preNode = null;
		while(endPositionNode != null){
			midNode = endPositionNode.next;
			endPositionNode.next = preNode;
			preNode = endPositionNode;
			endPositionNode = midNode;
		}
		
		return flag;
		
	}
~~~

### 给链表分区

将单向链表按某值划分成左边小，中间相等，右边大的情形。对于数组，这个问题好解，其实就是荷兰国旗问题，所以一种方法是将链表转换为数组，然后利用数组方便交换元素的特性，分区后再转换为链表，但是这种方式需要一个与链表等大的数组作为辅助空间，且不保证稳定性。

~~~java
	//首先将链表的每一个结点装入数组中，然后堆对数组进行荷兰国旗问题排序
	//最后按照调整后数组的顺序重新调整链表指针即可
	public static Node dutchFlagChain(Node head, int key){
		Node currentNode = head;
		
		//计算链表长度并准备等大数组
		int i = 0;
		while(currentNode != null){
			i++;
			currentNode = currentNode.next;
		}
		
		Node[] nodeArray = new Node[i];
		
		//将链表结点装入数组中
		i = 0;
		currentNode = head;
		while(currentNode != null){
			nodeArray[i++] = currentNode;
			currentNode = currentNode.next;
		}
		
		//用荷兰国旗问题算法对数组进行排序
		i = 0;
		int pre = -1;
		int end = nodeArray.length - 1;
		while(i < end){
			if(nodeArray[i].val > key){
				nodeSwap(nodeArray, i, end--);
			}else if(nodeArray[i].val < key){
				nodeSwap(nodeArray, pre + 1, i);
				pre++;
				i++;
			}else{
				i++;
			}
		}
		
		//重新调整链表的次序
		for(i = 0; i < nodeArray.length - 1; i++){
			nodeArray[i].next = nodeArray[i + 1];
		}
		nodeArray[nodeArray.length - 1].next = null;
		return nodeArray[0];
	}
	
	private static void nodeSwap(Node[] nodeArray, int i, int j){
		Node node = nodeArray[i];
		nodeArray[i] = nodeArray[j];
		nodeArray[j] = node;
	}
~~~

其实没有必要用这种复杂的方式，链表虽然不擅长交换元素，但是链表可以随意拆分和组合。设置三个区域，遍历链表时将结点分配到小中大三个区域，每个区域用一个链表记载结点，只需要头和尾指针即可代表一个区域，最后将三个区域头尾相连即可：

~~~java
	//这种算法无需辅助空间，且划分后除了相等部分，其余两边各自内部的相对次序不变
	//设置三个区域，遍历链表时将结点分配到小中大三个区域，每个区域用一个链表记载结点，只需要头和尾指针即可代表一个区域
	//最后将三个区域头尾相连即可
	//注意要处理特别情况，三个区域某个为空时
	public static Node dutchFlagChain_a(Node head, int key){
		
		//定义当前结点和三个区域的六个指针，准备遍历
		Node currentNode = head;
		
		Node smallNodeStart = null;
		Node smallNodeEnd = null;
		Node midNodeStart = null;
		Node midNodeEnd = null;
		Node bigNodeStart = null;
		Node bigNodeEnd = null;
		
		//遍历链表，将结点分到三个区域，如果指针是null那就将两个指针一同初始化
		while(currentNode != null){
			if(currentNode.val < key){
				if(smallNodeStart == null){
					smallNodeStart = smallNodeEnd = currentNode;
				}else{
					smallNodeEnd.next = currentNode;
					smallNodeEnd = currentNode;
				}
			}else if(currentNode.val > key){
				if(bigNodeStart == null){
					bigNodeStart = bigNodeEnd = currentNode;
				}else{
					bigNodeEnd.next = currentNode;
					bigNodeEnd = currentNode;
				}
			}else{
				if(midNodeStart == null){
					midNodeStart = midNodeEnd = currentNode;
				}else{
					midNodeEnd.next = currentNode;
					midNodeEnd = currentNode;
				}
			}
			
			currentNode = currentNode.next;
		}
		
		//将三个区域的尾全指向空，因为特殊情况的存在，这三个指针都有可能作为新链表的尾结点，故需要全部置空
		//这样后面将无需置空的部分修改掉即可
		
		//还有一种解决方法本算法没有采用：可以直接在创建各个区域结点时
		//每次循环直接记录下一个结点的值，立即将本节点指向空，在将指针移动到记录好的位置：
		//next = head.next;
		//head.next = null;
		//处理本节点数值分组
		//head = next;
		//这样就可以保证每个节点的初始指向为空，然后用结果去调整每个指向
		//这实际上在遍历的过程中彻底打乱了链表
		
		if(smallNodeEnd != null){smallNodeEnd.next = null;}
		if(midNodeEnd != null){midNodeEnd.next = null;}
		if(bigNodeEnd != null){bigNodeEnd.next = null;}
		
		//如果中间区域不为空就将它与大于区域连接起来
		//如果为空那么就把大于区域赋值给中间区域
		//大于区域没有必要判断空指针，因为指向空指针是可以的
		if(midNodeStart != null){
			midNodeEnd.next = bigNodeStart;
		}else{
			midNodeStart = bigNodeStart;
		}
		
		//如果小于区域不为空就将他和中间区域连接，否则继续赋值
		if(smallNodeStart != null){
			smallNodeEnd.next = midNodeStart;
		}else{
			smallNodeStart = midNodeStart;
		}
		
		//最后，小于区域的头部必然是新链表的头结点
		return smallNodeStart;
		
	}
~~~

### 判断链表是否有环

方法1：这种算法借助了一个哈希表，遍历时把节点装入集合内，每次检查新节点有没有装入过。如果有装入过就说明是环链表，如果没有就说明不是

~~~java
	//这种算法借助了一个集合，遍历时把节点装入集合内，每次检查新节点有没有装入过
	//如果有装入过就说明是环链表，如果没有就说明不是
	public static Node haveLoopChain(Node head){
		HashSet<Node> set = new HashSet<Node>();
		Node currentNode = head;
		while(currentNode != null && (!set.contains(currentNode))){
			set.add(currentNode);
			currentNode = currentNode.next;
		}
		if(currentNode != null){
			return currentNode;
		}else{
			return null;
		}
	}
~~~

方法2：这种算法不用辅助空间，设置两个指针，一个快指针一个慢指针，快指针一次走两步，慢指针一次走一步。直到两个指针重合，此时把快指针重新指向头结点，快慢指针一起一次走一步前进。再次重合的结点就是相交节点

~~~java
	public static Node haveLoopChain_a(Node head){
		Node fastNode = head;
		Node slowNode = head;
		//这里可以用dowhile也可以把判断相等的条件放入循环的后半部，结合break去实现
		do{
			if(fastNode.next == null){
				return null;
			}
			fastNode = fastNode.next.next;
			slowNode = slowNode.next;
		}while(!(fastNode == slowNode || slowNode == null || fastNode == null));
		
		if(slowNode == null || fastNode == null){
			return null;
		}
		
		fastNode = head;
		while(fastNode != slowNode){
			fastNode = fastNode.next;
			slowNode = slowNode.next;
		}
		
		return fastNode;
	}
~~~

### 判断两链表是否相交

判断两个链表是否相交，相交返回交点，不相交返回null

根据两个链表是否为环链表可以分多钟情况处理：

* 如果两个链表都是无环链表，那么就用无环链表的算法寻找
* 如果是有环则用对应的算法
* 如果一个无环一个有环肯定不会相交，因为无环链表的末结点是确定的，而有环链表必定结尾是个环

~~~java
	public static Node returnIntersect(Node head1, Node head2){
		Node loop1 = haveLoopChain_a(head1);
		Node loop2 = haveLoopChain_a(head2);
		if(loop1 == null && loop2 == null){
			return noLoopIntersect(head1, head2);
			//return noLoopIntersect_a(head1, head2);
		}else if(loop1 != null && loop2 != null){
			return loopIntersect(head1, loop1, head2, loop2);
		}else{
			return null;
		}
	}
~~~

1、两个无环链表求相交结点方法

借助哈希表的实现方式：

~~~java
	//        \          /
	//         \        /
	//          \      /
	//           \    /
	//            \  /
	//             \/
    //              |
	//              |
	
	//这种算法需要一个set，遍历链表1将所有节点装入其中
	//遍历链表2，遇到与链表1重合的结点返回该节点
	//如果至链表尾没有找到，则也返回该节点（此时为null）
	private static Node noLoopIntersect(Node head1, Node head2){
		HashSet<Node> set = new HashSet<Node>();
		Node currentNode = head1;
		while(currentNode != null){
			set.add(currentNode);
			currentNode = currentNode.next;
		}
		
		currentNode = head2;
		while(currentNode != null && (!set.contains(currentNode))){
			currentNode = currentNode.next;
		}
		
		return currentNode;
	}
~~~

还有一种不需要额外空间复杂度的算法，首先遍历两个链表得到链表的长度和最后一个结点，如果两个链表的最后一个结点不同，那么两个一定不相交。

如果相同说明相交，此时让较长的链表先走两个链表的差值步，然后两个指针再一同前进，直到找到相同的结点，即为首个相交结点

~~~java
	private static Node noLoopIntersect_a(Node head1, Node head2){
		Node currentNode1 = head1;
		Node currentNode2 = head2;
		int length1 = 0;
		int length2 = 0;
		while(currentNode1.next != null){
			length1++;
			currentNode1 = currentNode1.next;
		}
		
		while(currentNode2.next != null){
			length2++;
			currentNode2 = currentNode2.next;
		}
		
		if(currentNode1 != currentNode2){
			return null;
		}
		
		currentNode1 = length1 > length2 ? head1 : head2;
		currentNode2 = currentNode1 == head1 ? head2 : head1;
		int num = length1 > length2 ? (length1 - length2):(length2 - length1);
		
		for(int i = 0; i < num; i++){
			currentNode1 = currentNode1.next;
		}
		
		while(currentNode1 != currentNode2){
			currentNode1 = currentNode1.next;
			currentNode2 = currentNode2.next;
		}
		
		return currentNode1;
	}
~~~

2、求两个有环链表第一个相交结点

此时分为以下三种情况：

~~~
	//情形1：没有交点
	
	//情形2：
	//           \    /
	//            \  /
	//             \/
    //              |
	//              |
	//             / \
	//            /   \
	//            \   /
	//             \ /
	
	//情形3：
	//        \               /
	//         \             /
	//          \           /
	//           \         /
	//            \       /
	//             \     /
	//              -----
	//             /     \
	//             \     /
	//              -----
~~~

在之前的returnIntersect方法中，已经分别找到了两个链表的第一个环节点。如果两个链表的第一个环节点相等，就是情形2；如果不相等，那就看能不能通过遍历其中一个链表找到第二个链表的环节点，如果能找到就是情形3，否则就是情形1

~~~java
	private static Node loopIntersect(Node head1, Node loop1, Node head2, Node loop2){
		if(loop1 == loop2){
			return findLoopIntersect(head1, head2, loop1);
		}else{
			Node currentCode = head1;
			while(currentCode != null){
				//-----------------------------------------------
				//-------------错误-------------------------------
				//-----------------------------------------------
				if(currentCode == loop2){
					return loop2;
				}
				currentCode = currentCode.next;
			}
			
			return null;
		}
	}
	
	//对于情形2，就是无环链表找交点算法的翻版，只不过原来两个链表遍历在null处停止，现在在loop处停止
	private static Node findLoopIntersect(Node head1, Node head2, Node loop){
		Node currentNode1 = head1;
		Node currentNode2 = head2;
		int length1 = 0;
		int length2 = 0;
		while(currentNode1.next != loop){
			length1++;
			currentNode1 = currentNode1.next;
		}
		
		while(currentNode2.next != loop){
			length2++;
			currentNode2 = currentNode2.next;
		}
		
		currentNode1 = length1 > length2 ? head1 : head2;
		currentNode2 = currentNode1 == head1 ? head2 : head1;
		int num = length1 > length2 ? (length1 - length2):(length2 - length1);
		
		for(int i = 0; i < num; i++){
			currentNode1 = currentNode1.next;
		}
		
		while(currentNode1 != currentNode2){
			currentNode1 = currentNode1.next;
			currentNode2 = currentNode2.next;
		}
		
		return currentNode1;
	}
}
~~~

## 栈

栈是限定仅在表尾进行插入和删除操作的线性表

允许插入和删除的一端称为栈顶，另一端称为栈底，栈又被称为后进先出（Last In First Out）的线性表，简称LIFO结构

栈可以用顺序存储结构来实现，也可以用链式存储结构实现

栈的应用：

* 编译器使用栈来实现递归
* 运算表达式求值：计算逆波兰法表示的数学表达式的结果


### 用数组实现栈

~~~java
//用数组实现一个栈，只需要设置一个指针，每次进栈时指针向后移动，每次出栈时指针前移，每次处理好边界关系即可
class ArrayStack{
	private int[] arr;
	private int now;
	
	public ArrayStack(int length){
		arr = new int[length];
		now = 0;
	}
	public void push(int a){
		if(now == arr.length){
			throw new IllegalStateException("超出容量？");
		}else{
			arr[now] = a;
			now++;
		}
	}
	
	public int peek(){
		if(now == 0){
			throw new IllegalStateException("已经没有元素了");
		}
		return arr[now - 1];
	}
	
	public int pop(){
		 if(now == 0){
			 throw new IllegalStateException("已经没有元素了");
		 }
		 now--;
		 return arr[now];
	}
}
~~~

### 栈与递归

将一个栈逆序过来，要求用递归和操作栈的方法来实现：

~~~java
	//解题的关键在于利用栈的特性，先调用递归的方法后退出
	//如果直接将弹出的数字保存一下继续递归，结束之后再压回栈中
	//最后结果和初始栈的顺序一样
	//所以必须封装一个方法可以弹出栈底的元素并返回该元素
	public static void reverseStack(Stack<Integer> stack){
		if(stack.isEmpty()) {
			return;
		}
		int i = getAndRemoveLastEle(stack);
		reverseStack(stack);
		stack.push(i);
	}
	
	//这个方法用于弹出栈底的元素并返回该元素
	//可以采用首先弹出元素，然后向下递归，最后将元素再装回栈中的顺序设计
	//这样压回的顺序还是原来的顺序
	//只是最后如果栈为空就直接返回弹出的元素，然后向上一直传递
	//由于最后是返回语句，所以要把元素在返回语句之前再装回去就可以了
	public static int getAndRemoveLastEle(Stack<Integer> stack) {
		int num = stack.pop();
		if(stack.isEmpty()) {
			return num;
		}else {
			int res = getAndRemoveLastEle(stack);
			stack.push(num);
			return res;
		}
	}
~~~

### 栈与排序

给一个整形的栈，现在要把栈中数的顺序调整成从上到下是从大到小的，要求只能借助栈来完成

~~~java
	//按照另一个辅助栈栈顶和弹出元素之间的关系选择压入或者弹出
	//如果大小顺序不对就将辅助栈弹出至对了为止
	//不能直接将stack的索引指向辅助栈，因为辅助栈一旦回收这个指针就指向空了
	//要直接操作stack才行，指向克隆对象也不行
	public static Stack<Integer> sortStack(Stack<Integer> stack) {
		Stack<Integer> newStack = new Stack<Integer>();
		while(!stack.isEmpty()) {
			int val = stack.pop();
			while(!newStack.isEmpty() && newStack.peek() > val) {
				stack.push(newStack.pop());
			}
			newStack.push(val);
		}
		return newStack;
	}
~~~

### 用队列实现栈

~~~java
//用两个队列实现栈，每次出栈的时候都要把其中一个队列倒入另一个队列
//直至队列中还有一个元素的时候，弹出该元素，然后互换两个队列的索引
class TwoQueuesStack{
	private Queue<Integer> queue1;
	private Queue<Integer> queue2;
	private Queue<Integer> queue3;
	public TwoQueuesStack(){
		queue1 = new LinkedList<Integer>();
		queue2 = new LinkedList<Integer>();
	}
	
	public void push(int a){
		queue1.offer(a);
	}
	
	public int peek(){
		if(queue1.isEmpty()){
			throw new IllegalStateException("已经没有元素了");
		}
		
		while(queue1.size() > 1){
			queue2.offer(queue1.poll());
		}
		queue3 = queue2;
		queue2 = queue1;
		queue1 = queue3;
		int a = queue2.poll();
		queue1.offer(a);
		return a;
	}
	
	public int pop(){
		if(queue1.isEmpty()){
			throw new IllegalStateException("已经没有元素了");
		}
		
		while(queue1.size() > 1){
			queue2.offer(queue1.poll());
		}
		queue3 = queue2;
		queue2 = queue1;
		queue1 = queue3;
		return queue2.poll();
	}
}
~~~

### 单调栈

~~~java
	//单调栈
	// * 求一个数组中各位置中左边离该位置最近的比它大的数和右边离该位置最近的比它大的数
	// * 用两个integer数组表示出来，如果没有就置位null,要求时间复杂度On，假设数组中没有重复元素
	
	//建立一个栈，将数组元素依次放入栈中，每次要求栈中从底到顶都是从大到小，每次满足这个规律就进栈，否则使小于新数的部分出栈
	//每次出栈时记录下：出栈时是因为哪个数要进栈，这个数就是右边离该位置最近的比它大的数
	//出栈后的栈顶，这个数就是左边离该位置最近比它小的数
	//如果不存在出栈的原因，只是因为没有新的数了，那么置为null
	//如果出栈后栈为空，对应位置也置为null
	public static Integer[][] getTwoArrays(int[] arr){
		Integer[][] integerArray = new Integer[2][arr.length];
		Stack<Integer> stack = new Stack<Integer>();
		int k;
		for(int i = 0; i < arr.length; i++){
			System.out.println(stack);
			System.out.println(arr[i]);
			while(!stack.isEmpty() && arr[i] > arr[stack.peek()]){
				System.out.println("in");
				k = stack.peek();
				integerArray[1][k] = arr[i];
				stack.pop();
				integerArray[0][k] = stack.isEmpty() ? null : arr[stack.peek()];
			}
			stack.push(i);
		}
		while(!stack.isEmpty()){
			k = stack.peek();
			integerArray[1][k] = null;
			stack.pop();
			integerArray[0][k] = stack.isEmpty() ? null : arr[stack.peek()];
		}
		return integerArray;
	}
~~~

## 队列

队列是只允许在一端进行插入操作，而在另一端进行删除操作的线性表

队列是一种先进先出First In First Out的线性表，简称FIFO，允许插入的一端称为队尾，允许删除的一端称为队头。

队列可以用顺序存储结构来实现，也可以用链式存储结构实现

当队列用顺序存储结构来实现时，需要队头指针和队尾指针来标记队列元素在数组中的范围，随着入队和出队，队尾指针会超过数组定义的最大下标，此时会产生数组越界的错误，但实际上在数组初始位置还可能有空闲的区域，这种现象叫假溢出：

![QQ图片20221231201134](QQ图片20221231201134.png)

解决假溢出的办法是，创造一个头尾相接的顺序存储结构，这又被称为循环队列。队尾指针可以改为指向下标为0的位置，这样就不会溢出了：

![QQ图片20221231201715](QQ图片20221231201715.png)

### 用数组实现队列

~~~java
//用数组实现队列，用三个值，一个值指示队列大小，其余两个指示队头和队尾，处理好指针移动到数组末尾的边界条件即可
class ArrayQueue{
	private int[] arr;
	private int begin;
	private int end;
	private int size;
	public ArrayQueue(int a){
		arr = new int[a];
		begin = 0;
		end = 0;
		size = 0;
	}
	
	public void offer(int a){
		if(size == arr.length){
			throw new IllegalStateException("超出容量？");
		}
		arr[end] = a;
		if(end == arr.length - 1){
			end = 0;
		}else{
			end++;
		}
		size++;
	}
	
	public int peek(){
		if(size == 0){
			throw new IllegalStateException("已经没有元素了");
		}
		return arr[begin];
	}
	
	public int poll(){
		if(size == 0){
			throw new IllegalStateException("已经没有元素了");
		}
		size--;
		if(begin == arr.length - 1){
			begin = 0;
			return arr[arr.length - 1];
		}else{
			begin++;
			return arr[begin-1];
		}
		
	}
}
~~~

### 窗口最大值数组

生成窗口最大值数组：

有一个整型数组arr和大小为w的窗口从数组的最左边滑到最右边，窗口每次向右滑动一个位置
对于数组：[4,3,5,4,3,3,6,7]，窗口大小为3，那么首次出现时窗口是：4,3,5，然后是3,5,4，直到最后窗口中是3,6,7
写一个方法，入参为数组arr和w，求一个大小为n-w+1的数组，这个数组代表每个位置下窗口中的最大元素，此时应该返回[5,5,5,4,6,7]

~~~java
	//设置了一个双向队列完成这个方法，每次从数组中取出新值观察队列队尾是不是比这个数大，如果大就加入队尾，否则从队尾
	//将数取出，然后继续检查队尾直至队列中为空或队尾比该数大，加入队尾
	//每次窗口移动有数要取出时，检查队头的数下标是不是过期，然后取出队头的数
	//这个队列实现了在减小数据量的时候时时刻刻能取出最大值，队列存的是数组中的下标
	public static int[] getMaxInWindow(int[] arr, int size){
		if(arr == null || arr.length < size || size <= 0){
			return null;
		}
		int[] newArr = new int[arr.length - size + 1];
		LinkedList<Integer> list = new LinkedList<Integer>();
		for(int i = 0; i < arr.length; i++){
			while(!list.isEmpty() && arr[list.peekLast()] <= arr[i]){
				list.pollLast();
			}
			list.addLast(i);
			if(list.peekFirst() == i - size){
				list.pollFirst();
			}
			if(i >= size - 1){
				newArr[i - size + 1] = arr[list.peekFirst()];
			}
		}
		return newArr;
	}
~~~



## 字符串

### 子序列

打印一个字符串所有的子序列，包括空串。

~~~java
	//打印一个字符串所有的子序列，包括空串
	
	//首先将字符串转化为字符数组，从第一个位置开始拼接字符串，每个位置都可以选择拼接当前位置字符形成新的字符串
	//也可以选择不拼接，这样直到最后一个位置就是一个子序列，每次记录下当前位置已形成的字符串和字符数组进行递归
	public static void printAllSub(String str){
		printAllSub(str.toCharArray(), 0, "");
	}
	
	private static void printAllSub(char[] ch, int location, String Str){
		if(location == ch.length){
			System.out.println(Str);
		}else{
			printAllSub(ch, location + 1, Str);
			printAllSub(ch, location + 1, Str + ch[location]);
		}
		
	}
~~~

### 全排列

打印一个字符串的全排列，要求不出现重复值

~~~java
	//打印一个字符串的全排列，要求不出现重复值
	
	//对于一个字符串abcd，先让首位置的字符a与各位置互换，产生：abcd、bacd、cbad、dbca
	//然后向下推进一个位置，继续互换，直至推进到最后一个位置直接打印
	//在整个递归过程中要传递的信息是当前的数组也就是顺序，还有就是推进的位置
	//每次建立一个set来查询要互换对应位置的字母有没有加入过set
	//用这种方式来避免产生重复值
	public static void printAllPermutations(String str){
		printAllPermutations(str.toCharArray(), 0);
	}
	
	private static void printAllPermutations(char[] charArray, int position){
		if(position == charArray.length){
			System.out.println(new String(charArray));
		}else{
			Set<Character> set = new HashSet<>();
			for(int j = position; j < charArray.length; j++){
				if(!set.contains(charArray[j])){
					set.add(charArray[j]);
					swap(charArray, j, position);
					printAllPermutations(charArray, position + 1);
					swap(charArray, j, position);
				}
			}
		}
	}
	
	private static void swap(char[] charArray, int begin, int end){
		char ch = charArray[begin];
		charArray[begin] = charArray[end];
		charArray[end] = ch;
	}
~~~

### KMP算法

KMP算法：给两个字符串a和b，如果a是b的子串返回起始位置，如果不是返回-1，要求时间复杂度M+N

~~~java
	//KMP算法：给两个字符串a和b，如果a是b的子串返回起始位置，如果不是返回-1
	
	//得到辅助数组开始遍历，设置i和j分别指向字符数组a和b，向前推进的过程中如果对应位置字符相同就前进
	//如果不同就将i刷新为辅助数组对应i号位的位置继续前进，此时j不变
	//还需要注意如果在辅助数组的首位值是-1，跳转的值-1是非法的，故此时直接将j增1
	//此时一定是i和j处于0位置
	//最后一定i与j会有一个越界，如果j越界就说明检查完成，如果i越界就说明检查失败
	public static int KMP(String str1, String str2){
		if(str1 == null || str2 == null || str1.length() < 1 || str2.length() < str1.length()){
			return -1;
		}
		char[] a = str1.toCharArray();
		char[] b = str2.toCharArray();
		int[] numArray = getIntArray(a);
		int i = 0;
		int j = 0;
		while(i <= b.length - 1 && j <= a.length - 1){
			if(a[j] == b[i]){
				i++;
				j++;
			}else if(a[j] != b[i] && numArray[j] < 0){
				i++;
			}else{
				j = numArray[j];
			}
		}
		return (j == a.length ? (i - a.length) : -1);
	}
	
	//获得算法的辅助数组，这个辅助数组大小与传入数组相同，该int数组与char数组一一对应
	//加入char数组是这样的abcdefgabck,计算k对应位置的int数组就是3，为前缀相等区abc和后缀相等区abc的长度
	//这个长度就是3，且该长度为可能的最大长度（对应上面这个例子不能是10，不能两个串都包含所有前缀），
	//该int数组的0号位人为规定为-1，1号位人为规定为0（因为1号位前不存在前缀后缀，因为该前缀后缀在同一位置）
	private static int[] getIntArray(char[] b){
		if(b.length <= 0){
			return null;
		}else if(b.length == 1){
			return new int[]{-1};
		}
		int[] arr = new int[b.length];
		arr[0] = -1;
		arr[1] = 0;
		int key = 0, i = 2;
		while(i < b.length){
			//如果相等说明数组的值就是前一位的值加1
			if(b[key] == b[i - 1]){
				arr[i++] = ++key;
			//key大于0说明还有优化的空间，继续向前跳
			}else if(key > 0){
				key = arr[key];
			}else{
				//失去了匹配的可能，赋值为0
				arr[i++] = 0;
			}
		}
		return arr;
	}
~~~

### manacher算法

manacher算法：求一个字符串中最大回文子串长度，要求时间复杂度On

~~~java
	//首先用transfer方法先加工字符串，因为回文子串在延伸时存在偶串难以延伸的困难，所以要把每个字符之间加入一个‘#’
	//如aaabbbccc加工结束之后变为#a#a#a#b#b#b#c#c#c#
	//这样处理过的串一定是奇数串，延伸检查回文方便
	//定义一些变量，dia回转直径数组，nowPos目前最大右边界，core最大右边界对应的最左中心
	//基本计数i、目前最大回转直径maxDia、目前最大回转直径对应中心maxCore
	
	//开始遍历，遍历结束应该是最大右边界抵达数组末尾，此时如果有的位置直径还没有确定也不会出现更大的直径了
	//此时最大直径已经计算出来了
	//如果i > nowPos，说明当前位置在最大右边界外，此时扩展寻找最大回文
	//如果i <= nowPos 且dia[2 * core - i] - 1)/2 + i ) > nowPos
	//说明当前i位置相对core位置的对称点的直径扩展到了当前直径之外，此时i点的半径就是从i到nowPos
	//如果i <= nowPos 且dia[2 * core - i] - 1)/2 + i ) < nowPos
	//说明当前i位置相对core的对称点直径还在当前直径以内，此时对称 点的直径就是i点的直径
	//如果如果i <= nowPos 且dia[2 * core - i] - 1)/2 + i ) = nowPos
	//此时i点的回文直径至少是2 * (nowPos - i) + 1，还需向外延伸继续确定真正的直径
	public static String manacher(String str){
		String str1 = transfer(str);
		char[] charArray = str1.toCharArray();
		int[] dia = new int[str1.length()];
		int nowPos = -1, core = -1, i = 0, k, maxDia = Integer.MIN_VALUE, maxCore = Integer.MIN_VALUE;
		while(nowPos < dia.length - 1){
			if(i > nowPos || (i <= nowPos && ((dia[2 * core - i] - 1)/2 + i ) == nowPos)){
				k = i > nowPos ? 1 : nowPos - i;
				while((i + k) < charArray.length && (i - k) >= 0 && charArray[i + k] == charArray[i - k]){
					k++;
				}
				//如果最右边界没有更新core的位置就不更新
				core = nowPos < i + k - 1 ? i : core;
				//nowPos = Math.max(nowPos, i + k - 1);
				nowPos = i + k - 1;
				dia[i] = 2 * k - 1;
			}else if(((dia[2 * core - i] - 1)/2 + i ) > nowPos){
				dia[i] = 2 * (nowPos - i) + 1;
			}else if(((dia[2 * core - i] - 1)/2 + i ) < nowPos){
				dia[i] = dia[2 * core - i];
			}
			maxCore = maxDia < dia[i] ? core : maxCore;
			//每次记录下当前最大直径
			maxDia = Math.max(maxDia, dia[i++]);
		}
		maxCore = (maxCore - maxDia/2 + 1)/2;
		//当前最大直径除以2就是原字符串的直径（因为原来的字符串是处理过的）
		return str.substring(maxCore, maxCore + maxDia/2);
	}
	
	private static String transfer(String str){
		if(str == null || str.length() == 0){
			return null;
		}
		char[] charArray = str.toCharArray();
		char[] newCharArr = new char[charArray.length * 2 + 1];
		int k = 0;
		for(int i = 0; i < charArray.length; i++){
			newCharArr[k++] = '#';
			newCharArr[k++] = charArray[i];
		}
		newCharArr[k] = '#';
		return new String(newCharArr);
	}
~~~

# 树

## 定义

树是n(n>=0)个结点的有限集。n=0时称为空树。在任意一课非空树中：

* 有且仅有一个特定的称为根Root的结点
* 当n>1时，其余结点可分为m(m>0)个互不相交的有限集T1/T2/.../Tm，其中每一个集合本身又是一棵树，并且称为根的子树

如下图所示：

![QQ图片20230101103247](QQ图片20230101103247.png)

树的定义用到了递归的方法，也就是在树的定义中还用到了树的概念。下图就是根结点A的子树：

![QQ图片20230101103413](QQ图片20230101103413.png)

在树的定义中，有两个关键的地方：

* 根结点是唯一的，不可能存在多个根结点
* 子树的个数没有限制，但是它们一定是互不相交的。下面这种相交的子树就不符合树的定义：

![QQ图片20230101103554](QQ图片20230101103554.png)

## 相关概念

树的结点包含一个数据元素，及若干指向其子树的分支。

结点拥有的子树数称为结点的度（Degree）。度为0的结点称为叶结点Leaf或终端结点；度不为0的结点称为非终端结点或分支结点。

除了根结点之外，分支结点也称为内部结点。树的度是树内各结点的度的最大值

![QQ图片20230101104733](QQ图片20230101104733.png)

结点的子树的根称为该结点的孩子Child，相对应的该结点称为孩子的双亲Parent。

同一个双亲的孩子之间互称兄弟Sibling。

结点的祖先是从根到该结点所经分支上的所有结点，反之，以某结点为根的子树中的任一结点都称为该结点的子孙

![QQ图片20230101105028](QQ图片20230101105028.png)

结点的层次Level从根开始定义起，根为第一层，根的孩子为第二层。若某结点在第N层，则其子树的根就在第N+1层。

其双亲在同一层的结点互为堂兄弟。

树中结点的最大层次称为树的深度或高度，下面这棵树深度为4：

![QQ图片20230101105231](QQ图片20230101105231.png)

如果将树中结点的各子树看成从左到右是有次序的，不能互换的，则称该树为有序树，否则称为无序树。

森林是m（m>=0）颗互不相交的树的集合。这个树的集合也可以是同一颗树下不同子树的集合。

## 存储结构

### 双亲表示法

树除了根结点以外，其余每个结点都有自己的双亲。所以双亲表示法的树结点是由两部分组成：数据域data+指针域parent。这里的指针域是存储双亲结点在结点数组中的位置，一个树结构就由一个结点数组表示。

根结点由于没有双亲，所以它的parent值是-1。下面就是一个双亲表示的例子：

![QQ图片20230102194231](QQ图片20230102194231.png)

这样的存储结构，可以根据结点的parent指针很容易找到它的双亲结点，但是如果要知道结点的孩子是什么，需要遍历整个结构才行，此时我们可以给结点结构增加一个结点最左边孩子的域，称为长子域，没有孩子的结点就将该值设置为-1。如果很关注各兄弟之间的关系，还可以增加一个右兄弟域。

### 孩子表示法

这种表示方法下，每个结点有多个指针域，其中每个指针指向一颗子树的根结点，这种方法也叫多重链表表示法。

由于每个树结点的度不同，可以细分为下面两种方法解决：

* 树结点结构中，指针域的个数就等于树的度。这样在树种各结点的度相差很大时，是比较浪费空间的
* 按需分配，设计一个字段代表本节点子结点的数量，也就是指针域的个数

![QQ图片20230102200248](QQ图片20230102200248.png)

还有一种思路，把每个结点放到一个顺序存储结构的数组中，然后给每个结点的孩子建立一个单链表：

![QQ图片20230102200433](QQ图片20230102200433.png)

这种表示方法遍历起来、找兄弟结点很简单，但是知道某个结点的双亲是谁比较麻烦，所以可以额外给数组结点额外增加一个parent指针：

![QQ图片20230102200620](QQ图片20230102200620.png)

这种表示方法也被称为双亲孩子表示法。

### 孩子兄弟表示法

观察一棵树发现：任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。因此我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟。

这种表示方法的结点结构由三部分组成：数据域+第一个孩子的指针+右兄弟的指针

![QQ图片20230102201104](QQ图片20230102201104.png)

这种表示法查找某个节点的双亲也是比较麻烦的，所以我们可以给结点增加一个parent指针。

这个表示法最大的好处就是将一颗复杂的树变成了一颗二叉树。

## 二叉树的定义

二叉树是n(n>=0)个结点的有限集合，该集合或者为空集（空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。

在定义中需要注意：

* 每个结点最多有两棵子树，所以二叉树中不存在度大于2的结点
* 左子树和右子树是有顺序的，不能颠倒，即使结点只有一棵子树，也要区分它是左子树还是右子树

几种特殊的二叉树：

* 斜树

  所有的结点都只有左子树的二叉树叫左斜树；所有的结点都只有右子树的二叉树叫右斜树，这两者统称为斜树。

  斜树的特点就是每层只有一个结点，结点的个数与二叉树的深度相同。其实斜树就是树退化为线性表的形式。

* 满二叉树

  一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，它就是满二叉树。

  ![QQ图片20230102202942](QQ图片20230102202942.png)

  满二叉树的特点：

  * 叶子只能出现在最后一层
  * 2、非叶子结点的度一定是2
  * 3、在同样深度的二叉树，满二叉树的结点个数最多，叶子数最多

* 完全二叉树

  对一棵具有n个结点的二叉树按层序编号，如果编号为i的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。

  ![QQ图片20230102203438](QQ图片20230102203438.png)

  满二叉树一定是一棵完全二叉树，但完全二叉树不一定是满的。

  完全二叉树的一些特点：

  * 叶子结点只能出现在最下两层
  * 最下层的叶子一定集中在左部连续位置
  * 倒数第二层的叶子结点一定在右部连续位置
  * 如果结点度为1，则该结点只有左孩子，不存在只有右子树的情况
  * 同样结点数的二叉树，完全二叉树的深度最小

## 二叉树的性质

二叉树的重要性质：

* 在二叉树的第i层上，至多有2的i-1次方个结点（i>=1）
* 深度为k的二叉树，总的结点数至多有(2的k次方) - 1个结点（k>=1）
* 对任意一棵二叉树，如果叶子结点数为n（度为0的结点），度为2的结点数为m，则n=m+1
* 具有n个结点的完全二叉树的深度为[logn] + 1 （其中，log是以2为底的，[x]代表不大于x的最大整数）

还有一条性质是针对完全二叉树的。

对于一棵有n个结点的完全二叉树，结点按层序编号，对任一结点i有以下规律：

* 如果i=1，则它是根结点
* 如果i>1，则其双亲是结点[i/2]
* 如果2i>n，则结点i无左孩子，此时结点i是叶子结点；2i<=n时，其左孩子是结点2i
* 如果2i+1>n，则结点无右孩子；如果2i+1<=n，此时其右孩子结点是2i+1

对比下面这张图可以和规律一一对比：

![QQ图片20230102205421](QQ图片20230102205421.png)

### 寻找后继结点

在二叉树中找到一个结点的后继结点（后继结点就是在中序遍历中某个结点后面的结点就是该节点的后继结点）。假设该node有一个指向父节点的指针，根节点该指针指向null。

解决方法：分为两种情况考虑：

* 如果这个结点有右结点，那么后继结点就是右子树的最左结点
* 如果这个结点没有右结点，那么如果能一直向上找到这样一个结点：该节点的父节点的左孩子是该节点，那么后继结点就是该节点的父节点

~~~java
	class ParentNode{
		ParentNode left;
		ParentNode right;
		ParentNode parent;
		int val;
		ParentNode(int val){
			this.val = val;
		}
	}
	
	public static ParentNode getSuccessorNode(ParentNode node){
		if(node == null){
			return null;
		}
		if(node.right != null){
			return findMostLeftNode(node);
		}else{
			return findnextNode(node);
		}
	}
	
	private static ParentNode findMostLeftNode(ParentNode node){
		ParentNode currentNode = node.right;
		while(currentNode.left != null){
			currentNode = currentNode.left;
		}
		
		return currentNode;
	}
	
	private static ParentNode findnextNode(ParentNode node){
		ParentNode currentNode = node;
		ParentNode parentNode = node.parent;
		while(parentNode != null && parentNode.left != currentNode){
			currentNode = parentNode;
			parentNode = currentNode.parent;
		}
		
		return parentNode;
	}
~~~

### 判断完全二叉树

判断一棵树是不是完全二叉树

具体解决方案是：在二叉树的层序遍历中，如果一个结点只有右结点没有左结点直接返回false，如果一个结点没有孩子结点或者有左结点没有右结点，那么之后的结点必须都是叶子节点，否则不是完全二叉树。层序遍历走到结束还没有出现异常现象就返回true

~~~java
	public static boolean isCBT(BinaryNode<Integer> root){
		
		Queue<BinaryNode<Integer>> queue = new LinkedList<BinaryNode<Integer>>();
		queue.offer(root);
		boolean flag = false;
		while(!queue.isEmpty()){
			BinaryNode<Integer> node = queue.poll();
			if(node.left == null && node.right != null){
				return false;
			}
			if(flag && !(node.left == null && node.right == null)){
				return false;
			}
			if(node.left != null){
				queue.offer(node.left);
			}
			if(node.right != null){
				queue.offer(node.right);
			}else{
				flag = true;
			}
		}
		
		return true;
	}
~~~

### 完全二叉树结点数

求完全二叉树结点数：

~~~java
	//先一直向左结点延伸，求树的深度
	//然后观察结点的右结点，求右结点的深度，如果右结点的深度与当前层数之和等于树的深度
	//说明结点的左子树是一颗满二叉树，总结点个数就等于左子树个数+1+当前结点总个数
	//如果不等于说明右子树是一颗满二叉树，转而求左子树结点个数
	//已知树是满二叉树再知道树的深度可以直接求得结点数
	
	//该算法的时间复杂度分析：每层遍历一个结点，共logn次，每次遍历要求该节点的深度，平均次数logn/2
	//时间复杂度为ologn方
	public static int nodeNum(BinaryNode<Integer> root){
		if(root == null){
			return 0;
		}
		return nodeNum(root, 1, getLength(root));
	}
	
	private static int nodeNum(BinaryNode<Integer> node, int level, int sumLength){
		
		if(node.left == null && node.right == null){
			return 1;
		}
		int length = getLength(node.right);
		if(length + level != sumLength){
			return (1 << length) + nodeNum(node.left, level + 1, sumLength);
		}else{
			return (1 << length) + nodeNum(node.right, level + 1, sumLength);
		}
		
	}
	
	private static int getLength(BinaryNode<Integer> node){
		BinaryNode<Integer> currentNode = node;
		int sumLength = 0;
		while(currentNode != null){
			sumLength++;
			currentNode = currentNode.left;
		}
		return sumLength;
	}
~~~





## 二叉树的存储结构

二叉树的存储结构可以分为顺序存储结构和链式存储结构。

二叉树的顺序存储结构其实就是用一维数组存储二叉树中的结点，一棵完全二叉树的存储：

![QQ图片20230102210531](QQ图片20230102210531.png)

由于完全二叉树的优越性，顺序结构也可以完美的表示二叉树。对于一般的二叉树用顺序结构保存则有浪费，顺序存储结构一般只用于完全二叉树。

二叉树用链式存储结构保存时，给每个结点设置一个数据域和两个指针域，分别指向两个孩子。如果有需要，还可以增加一个parent指针：

![QQ图片20230102211201](QQ图片20230102211201.png)

## 遍历二叉树

主要的几种遍历方式：

* 前序遍历

  先访问本节点，然后前序遍历左子树，再前序遍历右子树。如下图二叉树的前序遍历结果是ABDGHCEIF

  ![QQ图片20230102212035](QQ图片20230102212035.png)

* 中序遍历

  先中序遍历左子树，然后访问本结点，最后中序遍历右子树。如下图遍历的顺序是GDHBAEICF

  ![QQ图片20230102212144](QQ图片20230102212144.png)

* 后序遍历

  以从左到右，先叶子后结点的方式，遍历访问左右子树，最后访问本结点。如下图遍历的顺序是GHDBIEFCA

  ![QQ图片20230102212413](QQ图片20230102212413.png)

* 层序遍历

  从树的第一层开始，从上而下逐层遍历。在同一层中，按从左到右的顺序遍历。如下图的遍历顺序为ABCDEFGHI

  ![QQ图片20230102212516](QQ图片20230102212516.png)

已知前序遍历和中序遍历序列，可以唯一确定一棵二叉树

已知后序遍历和中序遍历序列，可以唯一确定一棵二叉树

前面的几种遍历方式都需要额外空间复杂度，有一种morris遍历实现二叉树的前中后序遍历不需要额外空间复杂度

### 前中后序递归版

~~~java
	//树的前中后序遍历
	//实际上这三种遍历访问结点的顺序都是一致的，每个节点都会被访问3次
	//首次访问结点，左子树结束回到本节点，右子树结束回到本节点
	//前序遍历就是在这个唯一序列里各节点首次出现的序列，中序遍历是第二次出现的序列
	//后序遍历就是序列中最后一次出现的序列
	public static void preOrderRecur(BinaryNode<Integer> node){
		if(node == null){
			return;
		}
		
		System.out.print(node.element+" ");
		preOrderRecur(node.left);
		preOrderRecur(node.right);
	}
	public static void inOrderRecur(BinaryNode<String> node){
		if(node == null){
			return;
		}
		
		inOrderRecur(node.left);
		System.out.print(node.element+" ");
		inOrderRecur(node.right);
	}
	public static void posOrderRecur(BinaryNode<Integer> node){
		if(node == null){
			return;
		}
		
		posOrderRecur(node.left);
		posOrderRecur(node.right);
		System.out.print(node.element+" ");
	}
~~~

### 前序遍历非递归版

树的前序遍历非递归版：建立一个栈，先把根节点压入，弹出每一个节点并将它的右结点、左结点依次压栈，直至栈为空

~~~java
	//压中-》压左-》压右
	public static void preOrderUnRecur(BinaryNode<Integer> root){
		BinaryNode<Integer> node = root;
		if(node != null){
			Stack<BinaryNode<Integer>> stack = new Stack<>();
			stack.push(node);
			while(!stack.isEmpty()){
				node = stack.pop();
				System.out.print(node.element + " ");
				if(node.right != null){
					stack.push(node.right);
				}
				if(node.left != null){
					stack.push(node.left);
				}
			}
		}
	}
~~~

### 中序遍历非递归版

树的中序遍历非递归版：建立一个栈，每次将结点及其左边一列全部压入，然后将右结点压入栈中

每次循环把判断限制在node上，为空弹栈并向右移动，不为空则压栈向左移动

~~~java
	//压左-》压中-》压右
	public static void inOrderUnRecur(BinaryNode<Integer> root){
		BinaryNode<Integer> node = root;
		if(node != null){
			Stack<BinaryNode<Integer>> stack = new Stack<>();
			while((!stack.isEmpty()) || node != null){
				if(node != null){
					stack.push(node);
					node = node.left;
				}else{
					node = stack.pop();
					System.out.print(node.element + " ");
					node = node.right;
				}
			}
		}
	}
~~~

### 后续遍历非递归版

~~~java
	//树的后序遍历非递归版，代码与树的前序遍历非递归版很像，前序是压中-》压左-》压右
	//这里仅仅调整了压入的顺序，改为了压中-》压右-》压左
	//然后把每次的结果再次压入一个栈中再取出
	//最后就能达到后序遍历的效果
	
	//压左-》压右-》压中
	public static void posOrderUnRecur(BinaryNode<Integer> root){
		BinaryNode<Integer> node = root;
		Stack<Integer> intStack = new Stack<>();
		if(node != null){
			Stack<BinaryNode<Integer>> stack = new Stack<>();
			stack.push(node);
			while(!stack.isEmpty()){
				node = stack.pop();
				intStack.push(node.element);
				if(node.left != null){
					stack.push(node.left);
				}
				if(node.right != null){
					stack.push(node.right);
				}
			}
		}
		
		while(!intStack.isEmpty()){
			System.out.print(intStack.pop() + " ");
		}
	}
~~~





## 二叉树的建立

将二叉树的每个结点的空指针都引出一个虚节点，其值为一个特定值，比如#，这种处理后的二叉树为原二叉树的扩展二叉树。扩展二叉树就可以做到一个遍历序列确定一棵二叉树了，例如下面的树，前序遍历序列就是AB#D##C##

![QQ图片20230114105605](QQ图片20230114105605.png)

用这个前序遍历的序列就能在内存中生成一棵二叉树了。

序列化还有其他的用处，例如判断一个树是否是另一个树的子树时，可以判断树A的序列化字符串是否是B的字符串的一部分，如果是就代表是子树。

### 用单调栈建立树

下面看一个问题：把一个不含重复元素的数组转换为一颗二叉树，这颗二叉树节点都比它的子节点大，要求构造过程中用的时间复杂度和额外空间复杂度都不超过ON。

要生成这样一棵树要按下列的原则进行建立：每个元素的父节点都是它左边遇见的第一个比它大的数和右边第一个比它大的数

按这样的原则建立树可以构造一颗唯一确定的二叉树，确定了思路之后用单调栈来解决：

~~~java
	//要生成这样一棵树要按下列的原则进行建立：每个元素的父节点都是它左边遇见的第一个比它大的数和右边第一个比它大的数
	//的较小值，如果一个节点是数组中的最大值那么它就是最大值
	//按这样的原则建立树可以构造一颗唯一确定的二叉树
	//如果一个节点有两个左节点那么肯定会导出矛盾的结果
	//确定了思路之后用单调栈来解决
	public static BinaryNode<Integer> getTree(int[] arr){
		Stack<Integer> stack = new Stack<Integer>();
		HashMap<Integer, BinaryNode<Integer>> map = new HashMap<Integer, BinaryNode<Integer>>();
		for(int i = 0; i < arr.length; i++) {
			map.put(arr[i], new BinaryNode<Integer>(arr[i]));
		}
		for(int i = 0; i < arr.length; i++) {
			while((!stack.isEmpty()) && arr[i] > stack.peek()) {
				int num = stack.pop();
				int next = stack.isEmpty() ? Integer.MAX_VALUE : stack.peek();
				if(next > arr[i]) {
					map.get(arr[i]).left = map.get(num);
				}else {
					map.get(next).right = map.get(num);
				}
			}
			stack.push(arr[i]);
		}
		while(!stack.isEmpty()) {
			int num = stack.pop();
			if(!stack.isEmpty()) {
				map.get(stack.peek()).right = map.get(num);
			}else {
				return map.get(num);
			}
		}
		return null;
	}
~~~

### 先序遍历序列化

先序遍历序列化分为递归方式和非递归方式：

~~~java
	//序列化
	//用一个字符串表示一个二叉树，每个节点之间用！隔开，#代表空节点，所有的有值结点的左右孩子都要遍历到
	//组成的字符串就可以代表一个二叉树，顺序是中-》左-》右
	public static String serialByPre(BinaryNode<Integer> root){
		String str = new String();
		if(root == null){
			return "#!";
		}
		str = str + root.element + "!";
		str = str + serialByPre(root.left);
		str = str + serialByPre(root.right);
		return str;
	}
	//序列化先序非递归
	public static String preXu(BinaryNode<Integer> node){
		String str = "";
		if(node != null){
			Stack<BinaryNode<Integer>> stack = new Stack<BinaryNode<Integer>>();
			stack.push(node);
			while(!stack.isEmpty()){
				node = stack.pop();
				if(node == null){
					str = str + "#!";
				}else{
					str = str + node.element + "!";
				}
				if(node != null){
					stack.push(node.right);
					stack.push(node.left);
				}
			}
		}
		return str;
	}
~~~

对应的反序列化方式：

~~~java
	//反序列化:先序遍历
	
	//将字符串用！分成字符串数组，依次装入队列中，传入递归函数
	//在递归函数中将队列的值弹出，如果是#则返回，否则创建节点，递归左结点和右结点
	//如果不借助队列，那么递归数组需要传入数组和下标，现在装入队列后直接传递队列的参数即可
	public static BinaryNode<Integer> reconByPreString(String str){
		if(str.equals("#")){
			return null;
		}
		
		String[] strArray = str.split("!");
		Queue<String> queue = new LinkedList<String>();
		for(int i = 0; i < strArray.length; i++){
			queue.offer(strArray[i]);
		}
		return reconByPreString(queue);
	}
	
	public static BinaryNode<Integer> reconByPreString(Queue<String> queue){
		
		if(!queue.isEmpty()){
			String str = queue.poll();
			if(str.equals("#")){
				return null;
			}else{
				BinaryNode<Integer> node = new BinaryNode<Integer>(new Integer(str));
				node.left = reconByPreString(queue);
				node.right = reconByPreString(queue);
				return node;
			}
		}
	
		return null;
	}
~~~

### 层序遍历序列化

层序遍历序列化其实就是改造了树的层序遍历：

~~~java
	//序列化：层序遍历
	
	//创建一个队列来记录左右结点的次序
	//让根节点入队列，判断出队列的结点左右孩子结点是否为空，如果不为空打印入栈，为空直接加#！
	public static String serialByLevel(BinaryNode<Integer> root){
		String str = new String();
		if(root == null){
			return "#!";
		}
		
		Queue<BinaryNode<Integer>> queue = new LinkedList<>();
		queue.offer(root);
		str = str + root.element + "!";
		while(!queue.isEmpty()){
			BinaryNode<Integer> node = queue.poll();
			if(node.left != null){
				str = str + node.left.element + "!";
				queue.offer(node.left);
			}else{
				str = str + "#!";
			}
			
			if(node.right != null){
				str = str + node.right.element + "!";
				queue.offer(node.right);
			}else{
				str = str + "#!";
			}
		}
		
		return str;
	}
~~~

对应的反序列化方式：

~~~java
	//反序列化：层序遍历
	
	//创建一个队列记录一层结点的次序
	//先将根节点入队列，每次出对列就根据数组创建自己的左右孩子，并判断他们是否为空，如果不为空就加入队列
	public static BinaryNode<Integer> reconByLevelString(String str){
		
		int i = 0;
		String[] strArray = str.split("!");
		BinaryNode<Integer> root = createNode(strArray[i++]);
		BinaryNode<Integer> node;
		Queue<BinaryNode<Integer>> queue = new LinkedList<>();
		if(root != null){
			queue.offer(root);
		}
		
		while(!queue.isEmpty()){
			node = queue.poll();
			node.left = createNode(strArray[i++]);
			node.right = createNode(strArray[i++]);
			if(node.left != null){
				queue.offer(node.left);
			}
			if(node.right != null){
				queue.offer(node.right);
			}
		}
		
		return root;
	}
	
	public static BinaryNode<Integer> createNode(String str){
		if(str.equals("#")){
			return null;
		}
		return new BinaryNode<>(new Integer(str));
	}
~~~







## 线索二叉树

线索二叉树就是在树结点的结构中，加入了指向前驱和后驱结点的指针，这样的二叉树就变成了一个链表，也叫二叉链表，线索链表，响应的二叉树就被称为线索二叉树。这里面说的前驱和后驱都是相对于树的中序遍历而言的。

我们可以把二叉树定义中，指向右孩子结点的指针改为指向它的后继结点：

![QQ图片20230102222833](QQ图片20230102222833.png)

也可以将二叉树定义中，指向左孩子结点的指针，改为指向它的前继结点：

![QQ图片20230102222934](QQ图片20230102222934.png)

线索二叉树，等于是把二叉树转变成了一个双向链表，对插入删除结点都比较方便，对二叉树以某种次序遍历使其变为线索二叉树的过程称为线索化。

线索二叉树可以有选择性地记录左右孩子结点信息和前驱后驱结点的信息

如果所用的二叉树需要经常遍历或者查找结点，查找前驱和后继，采用线索二叉树会很方便

## 赫夫曼树

在判卷的时候，需要对不同成绩的学生给出评价结果，一个直观的评价方式是这样的：

![QQ图片20230102225903](QQ图片20230102225903.png)

如果我们已知学生的成绩分布，则可以想办法优化这个过程：

![QQ图片20230102225942](QQ图片20230102225942.png)

为了让占比多的分数段的同学的成绩，在评价的时候少判断几次，可以对判断流程进行优化：

![QQ图片20230102230053](QQ图片20230102230053.png)

我们可以把上面的两个判断过程，简化为叶子结点带权的二叉树：

![QQ图片20230102230153](QQ图片20230102230153.png)

从树中一个结点到另一个结点之间的分支构成两个节点之间的路径，路径上的分支数目称为路径长度。对于二叉树a来说，根结点到结点D的路径长度就为4

树的路径长度就是从树根到每一个结点的路径长度之和。如果考虑到带权的结点，树的带权路径长度就是各路径与权乘积之和。带权路径最小的二叉树称为赫夫曼树，也叫最优二叉树。

生成赫夫曼树的过程，首先把有权值的叶子结点按照从小到大的顺序排列，如A5、E10、B15、D30、C40

然后取最小的两个节点，相对较小的为左孩子，相对较大的为右孩子，生成一个新的节点N1，N1的权值就是两个叶子的权值15：

![QQ图片20230102230652](QQ图片20230102230652.png)

然后接着取一个结点拼装到二叉树中，生成一个新的根结点，依旧按照相对较小的为左孩子，相对较大的为右孩子的原则，合并树：

![QQ图片20230102230955](QQ图片20230102230955.png)

赫夫曼编码可以将一段内容尽可能的压缩到较小的编码方式，大致思路就是根据字母出现的频率生成最优二叉树，二叉树的每个路径都代表0或者1，用从树根到叶子经过的路径的0或1来编码。

# 图

## 定义

图（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为G(V,E)，其中G表示一个图，V是图G中顶点的集合，E是图G中边的集合。

定义中几个需要注意的地方：

* 线性表中我们吧数据元素叫元素，树中叫结点，在图中称之为顶点（Vertex）
* 线性表中没有数据元素称为空表；树中没有结点称之为空树；而图中则不允许有顶点，图的定义强调了顶点集合V有穷非空
* 线性表中相邻的元素之间具有线性关系；在树结构中，相邻两层的结点具有层次关系；在图中，任意两个顶点之间都可能有关系，顶点之间的逻辑关系用边来表示，边集可以是空的

## 有向边和无向边

无向边：若顶点vi到vj之间的边没有方向，则称这条边为无向边（edge），用无序偶对(vi,vj)来表示。

如果图中任意两个顶点之间的边都是无向边，则称该图为无向图。

对下面左图的无向图G来说，G={V,E}，其中顶点集合V={A,B,C,D}，边集合E={(A,B),(B,C),(C,D),(D,A),(A,C)}

![QQ图片20230103205916](QQ图片20230103205916.png)

有向边：若从顶点vi到vj的边有方向，则称这条边为有向边，也称为弧(Arc)，用有序偶\<vi,vj>，其中vi称为弧尾，vj称为弧头。

如果图中任意两个顶点之间的边都是有向边，则称该图为有向图。

对上面右图的有向图G来说，G={V,E}，其中顶点集合V={A,B,C,D}，边集合E={\<A,D\>,\<B,A>,\<C,A>,\<B,C>}

在图中，若不存在顶点到其自身的边，且同一条边不重复出现，则称这样的图为简单图。下面两个图就不是简单图：

![QQ图片20230103210439](QQ图片20230103210439.png)

在无向图中，如果任意两个顶点都存在边，则称该图为无向完全图。含有n个顶点的无向完全图有n(n-1)/2条边。下面的就是一个无向完全图，因为每个节点都要与除了它的其他顶点连线，所以共n(n-1)条边，再除以2代表除去重复的边。

![QQ图片20230103210724](QQ图片20230103210724.png)

在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图。含有n个顶点的有向完全图有n(n-1)条边：

![QQ图片20230103210845](QQ图片20230103210845.png)

有很少条边或弧的称为稀疏图，反之称为稠密图。这里的稀疏和稠密是模糊的概念，都是相对而言的。

有些图的边或弧具有与它相关的数字，这种与图的边或弧相关的数叫权（Weight），这种带权的图通常称为网（Network）

如果图A的顶点集和边集同时是图B的顶点集和边集的子集，称A为B的子图。下面有背景的图均是左侧无背景图的子图：

![QQ图片20230103211222](QQ图片20230103211222.png)

## 顶点与边

对于无向图，一条边上的两个顶点v1、v2称为邻接点，此时称v1和v2相邻接，边(v1,v2)依附于顶点v1和v2，或者说边(v1,v2)与顶点v1、v2相关联。

顶点v的度Degree是和v相关联的边的数目，记为TD(v)。图的边数等于各顶点度数和的一半。

对于有向图，一条有向边\<v1,v2>，称顶点v1邻接到顶点v2，顶点v2邻接自顶点v1，弧\<v1,v2>和顶点v1、v2相关联。

以顶点v为头的弧的数目称为v的入度（InDegree），记为ID(v)；以顶点v为尾的弧的数目称为v的出度（OutDegree），记为OD(v)；顶点v的度等于出度+入度。

在有向图中，各顶点的总出度=总入度

图中从一个顶点到另一个顶点的路径是一个顶点序列，下图就列举了从顶点B到顶点D的四种不同路径：

![QQ图片20230103212805](QQ图片20230103212805.png)

注意，当有向图的时候，路径也是有向的，路径顶点序列中不能出现边集以外的边，例如下面列举了从B到D的路径，而从顶点A到B就不存在路径：

![QQ图片20230103212939](QQ图片20230103212939.png)

树中根结点到任意结点的路径是唯一的，但是图中顶点与顶点之间的路径却是不唯一的。

路径的长度是路径上边或弧的数目。

第一个顶点到最后一个顶点相同的路径称为环（Cycle）。序列中顶点不重复出现的路径称为简单路径。除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为简单回路或简单环。

下面的两个图粗线都构成环，但是右侧因为顶点c在路径中的重复，且不是第一个和最后一个顶点，它就不是简单环了：

![QQ图片20230103213835](QQ图片20230103213835.png)

## 连通图

在无向图G中，如果从顶点v1到顶点v2有路径，则称v1和v2是连通的，如果对于图中属于顶点集的任意两个顶点vi、vj都是连通的，则称G是连通图（Connected Graph），下面左图就不是连通图，右图是连通图：

![QQ图片20230103214132](QQ图片20230103214132.png)

无向图中的极大连通子图称为连通分量，连通子图拥有极大顶点个数。上面的右图就是左图的一个连通分量。

在有向图G中，如果对属于顶点集的任意两个顶点vi、vj，从vi到vj和从vj到vi都存在路径，则称G是强连通图。有向图中的极大强连通子图称做有向图的强连通分量。对于下面的左图来说，它不是强连通图，因为A到D存在路径，而D到A不存在路径。右图就是强连通图，且右图是左图的极大强连通子图：

![QQ图片20230103215159](QQ图片20230103215159.png)

一个连通图的生成树是一个极小的连通子图，它含有图中全部的n个顶点，但只有足以构成一棵树的n-1条边。如果一个图有n个顶点和小于n-1条边，则它是非连通图；如果他多于n-1条边，则它必定构成一个环。

下图的图1 去掉两条边后，得到的图2和图3就是生成树，但有n-1条边不一定是生成树，例如图4：

![QQ图片20230103215524](QQ图片20230103215524.png)

如果一个有向图恰好有一个顶点的入度为0，其余顶点的入度均为1，则它是一棵有向树。

一个有向图的生成森林由若干棵有向树组成，含有图中全部顶点，但只有足以构成若干棵不相交的有向树的弧。例如下面图1是一棵有向树，去掉一些弧后，它可以分解为两棵有向树图2和图3，它们两个就是图1的生成森林：

![QQ图片20230103215856](QQ图片20230103215856.png)

## 图的存储结构

图的存储结构主要描述的是顶点之前的关系，下面四张图仔细观察发现，它们其实就是同一个图，只不过顶点的位置不同，造成了表象不同：

![QQ图片20230103220342](QQ图片20230103220342.png)

因为任意两个顶点都可能存在联系，所以图不可能用简单的顺序结构来表示，如果用多重链表表示的话，因为各顶点的度不同，则会造成很多指针存储空间的浪费。

### 邻接矩阵

考虑图是由顶点和边或弧两部分组成，合在一起比较困难，所以考虑分别用两个结构来存储。顶点用一维数组来保存，边或弧用一个二维数组来保存，这就是邻接矩阵（Adjacency Matrix）存储方式。

邻接矩阵是这样一个矩阵，它的ij位置为1代表存在vi到vj的边，下面是一个无向图用邻接矩阵的表示方法：

![QQ图片20230104214049](QQ图片20230104214049.png)

无向图的邻接矩阵的对角线总是0，因为不存在顶点到自身的边。由于是无向图，所以它一定是一个对称矩阵。

顶点vi的度=邻接矩阵第i行的元素之和。顶点vi的所有邻接点其实就是邻接矩阵第i行所有元素值为1对应的列。

下面的一个有向图的邻接矩阵表示案例：

![QQ图片20230104214443](QQ图片20230104214443.png)

有向图的邻接矩阵并不是对称矩阵。vi的入度=第i列各数之和，vi的出度=第i行各数之和。

每条边上带有权的图是网，下面是一个有向网图用邻接矩阵表示的案例：

![QQ图片20230104214743](QQ图片20230104214743.png)

在网的邻接矩阵中，对角线上的值都是0，每个位置的值代表对应边的权值，不存在的边对应位置为一个最大值。

### 邻接表

对于边数相对顶点较少的图，用邻接矩阵表示是非常浪费空间的，此时邻接矩阵中有大量空间是默认值：

![QQ图片20230104215416](QQ图片20230104215416.png)

可以考虑用链式结构来保存边的信息以节约空间。

邻接表（Adjacency List）是数组与链表相结合的存储方式。它用一个一维数组来表示顶点，然后每个顶点有指向它邻接点的指针，它的多个邻接点形成一个单链表，无向图称为顶点vi的边表，有向图称为顶点vi作为弧尾的出边表。

下面是一个无向图的邻接表结构：

![QQ图片20230104215830](QQ图片20230104215830.png)

如果想知道某个顶点的度，其实就是查找顶点对应边表中结点的个数。

想判断vi到vj是否存在边，需要去对应边表中确认是否有对应下标的结点。求顶点的所有邻接点，实际上就是对此顶点的边表进行遍历。

有向图的邻接表结构是类似的，不同之处在于有向图由于有方向，所以我们是以顶点为弧尾来存储边表的，这样很容易得到每个顶点的出度，但有时也为了便于确定顶点的入度，建立一个以顶点为弧头的边表，此时称为有向图的逆邻接表。下面就是有向图的邻接表，和对应的逆邻接表：

![QQ图片20230104220313](QQ图片20230104220313.png)

对于带权值的网图，可以在边表结点定义中再增加一个weight的数据域，存储权信息即可：

![QQ图片20230104220408](QQ图片20230104220408.png)

### 十字链表

对于有向图来说，邻接表是由缺陷的，只能解决出度或者入度的问题，不能同时解决两个问题。十字链表（Orthogonal List）将邻接表和逆邻接表结合起来，容易求得顶点的出度和入度。

顶点表结构由三个部分组成：

* data：数据域
* firstin：入边表头指针，指向该顶点入边表中的第一个结点
* firstout：出边表头指针，指向该顶点出边表中的第一个结点

边表结点结构：

* tailvex：弧起点在顶点表的下标
* headvex：弧终点在顶点表的下标，它和tailvex就构成了唯一一条边
* headlink：入边表指针域，指向终点相同的下一条边
* taillink：出边表指针域，指向起点相同的下一条边

下面是一个十字链表案例：

![QQ图片20230104223301](QQ图片20230104223301.png)

### 邻接多重表

无向图的邻接表存在一个问题，如果要删除一条边，必须找到这条边的两个边表结点进行操作：

![QQ图片20230104223452](QQ图片20230104223452.png)

邻接多重表与邻接表的区别就是边表结构不同，它由几个部分组成：

* ivex：边依附的两个顶点其中之一在顶点表中下标
* ilink：指向依附顶点ivex的下一条边
* jvex：边依附的两个顶点其中之一在顶点表中下标
* jlink：指向依附顶点jvex的下一条边

下面是一个邻接多重表案例：

![QQ图片20230104223800](QQ图片20230104223800.png)

邻接多重表与邻接表的区别：同一条边在邻接表中要用两个结点表示，而在邻接多重表中只有一个结点。这样对边的操作就方便多了，例如要删除一条边v0v2只需要将6、9的链接改为指向空即可。

### 边集数组

边集数组是由两个一维数组组成：

* 一个是存储顶点的信息
* 一个是存储边的信息，这个边数组每个元素由一条边的起点下标、终点下标和权组成

下面是一个边集数组的例子：

![QQ图片20230104224326](QQ图片20230104224326.png)

边集数组关注的是边的集合，在边集数组中查找一个顶点的度需要扫描整个数组。它更适合对边依次进行处理的操作，不适合对顶点相关的操作。

## 遍历

图的遍历可分为两种方案：深度优先遍历和广度优先遍历

* 深度优先遍历：Depth First Search，简称DFS，可以用递归或者栈实现
* 广度优先遍历：Breadth First Search，简称BFS，用队列实现

它们在时间复杂度上是一样的，不同之处仅仅在于对顶点访问顺序的不同

## 自定义图代码

### 邻接矩阵实现

基于邻接矩阵表示一个图MatrixGraph类，要实现的类与方法：Vertex、空参构造、addVertex、addEdge、displayVertex、dfs、bfs、degree

~~~java
class MatrixGraph{
	
	//ver代表顶点集合
	private Vertex[] ver;
	//mat代表边矩阵
	private int[][] mat;
	//顶点集合和边矩阵的初始大小
	private static final int DEFAULT_SIZE = 20;
	//verSize代表实际顶点个数
	private int verSize;
	//dfs用的栈
	private Stack<Integer> stack;
	//bfs用的队列
	private Queue<Integer> queue;
	
	//顶点的嵌套类
	private static class Vertex{
		//分别代表顶点名和指示是否遍历过的标志
		String name;
		boolean wasVisited;
		
		//有参构造，默认结点未被初始化
		public Vertex(String name){
			this.name = name;
			wasVisited = false;
		}
	}
	
	//图的无参构造
	public MatrixGraph(){
		//分别建立边矩阵和顶点集合以默认大小
		ver = new Vertex[DEFAULT_SIZE];
		mat = new int[DEFAULT_SIZE][DEFAULT_SIZE];
		//初始化顶点个数为0
		verSize = 0;
		//遍历边矩阵把各元素初始化为0
		for(int i = 0 ; i < DEFAULT_SIZE ; i++){
			for(int j = 0 ; j < DEFAULT_SIZE ; j++){
				mat[i][j] = 0;
			}
		}
	}
	
	//添加顶点
	public void addVertex(String st){
		//将结点添加进入顶点集合中
		ver[verSize] = new Vertex(st);
		//并将顶点个数加1
		verSize++;
	}
	
	//添加边
	public void addEdge(int begin , int end){
		//不允许添加自己到自己的边
		if(begin == end)return;
		//因为是对称矩阵所以两个数都要初始化
		mat[begin][end] = 1;
		mat[end][begin] = 1;
	}
	
	//打印一个顶点
	public void displayVertex(int i){
		System.out.print(ver[i].name+" ");
	}
	
	//返回顶点的度
	public int degree(int k){
		int degree = 0;
		//遍历边矩阵的一行，对等于1的点计数
		for(int i = 0 ; i < verSize ; i++){
			if(mat[k][i] == 1){
				degree++;
			}
		}
		return degree;
	}
	
	//非递归法借助栈实现dfs
	public void dfs1(){
		//新建栈并把第一个顶点压入栈中
		stack = new Stack<>();
		stack.push(0);
		//打印第一个顶点，也可以做其他操作
		displayVertex(0);
		//把第一个顶点访问标记更新
		ver[0].wasVisited = true;
		
		//循环条件：栈不为空
		//如果栈为空代表遍历结束
		while(!stack.empty()){
			//将栈顶元素拿出放入hasNext方法中获得路径中下一个未访问的顶点
			int j = hasNext(stack.peek());
			//如果该顶点存在
			if(j != -1){
				//将该顶点对应的编号压入栈中
				//打印该顶点并更新标记
				stack.push(j);
				ver[j].wasVisited = true;
				displayVertex(j);
			}else{
				//如果该顶点没有下一个未访问顶点
				//那就将栈弹出，相当于按原路返回寻找新的可能路径
				stack.pop();
			}
		}
		
		//最后更新所有顶点标记做好下一次遍历准备
		for(int k = 0 ; k < verSize ; k++){
			ver[k].wasVisited = false;
		}
	}
	
	//递归法实现dfs
	public void dfs2(){

		//遍历所有顶点调用递归的dfs方法
		//这种递归方式决定了每次找不到下一个点时会尽可能小的寻找新的起始点
		//所以这与栈实现的遍历方式结果不同
		for(int i = 0 ;i < verSize;i++){
			//如果已经遍历过该顶点那么就直接进入下一次循环
			if(ver[i].wasVisited == false){
				dfs(i);
			}
		}
		
		//最后更新所有顶点标记做好下一次遍历准备
		for(int k = 0 ; k < verSize ; k++){
			ver[k].wasVisited = false;
		}
	}
	
	//递归方法
	private void dfs(int i){
		
		//更新标记并打印该顶点
		ver[i].wasVisited = true;
		displayVertex(i);
		
		//获取下一个顶点，如果存在继续递归，不存在结束
		//相当于一条路径走到了尽头，此时返回到上面的for位置
		//继续寻找新顶点
		int j = hasNext(i);
		if(j != -1){
			dfs(j);
		}
	}
	
	//hasNext是判断顶点周围有没有未访问顶点的方法
	private int hasNext(int k){
		
		//遍历周围每一个顶点，相当于遍历边矩阵的一行，如果为1，说明该列号是相邻顶点
		//此时查看该节点，如果没有被访问过，就返回该顶点号
		for(int i = 0;i < verSize;i++){
			if(mat[k][i] == 1 && ver[i].wasVisited == false){
				return i;
			}
		}
		
		//如果遍历结束没有找到未访问顶点，那么返回-1
		return -1;
	}
	
	//bfs遍历图
	public void bfs(){
		//新建一个队列
		queue = new LinkedList<Integer>();
		//将0放入队列中,并将其标志更新
		queue.offer(0);
		ver[0].wasVisited = true;
		
		//循环条件是队列不为空
		while(!queue.isEmpty()){
			//取出队列里的值并打印
			//这里吧更新操作放入了下个方法中
			//因为在更新队列的时候有可能出现重复放入的现象
			//所以要在顶点放入队列的时候把控住
			int j = queue.poll();
			displayVertex(j);
			//将j周围的顶点放入队列中
			queue = takeInQueue(queue , j);
		}
		
		//最后更新所有顶点标记做好下一次遍历准备
		for(int k = 0 ; k < verSize ; k++){
			ver[k].wasVisited = false;
		}
	}
	
	//将周围的顶点放入队列中
	private Queue<Integer> takeInQueue(Queue<Integer> queue , int i){
		
		//遍历边矩阵中的一行，如果有顶点没有被访问就将其放入队列中
		for(int k = 0 ; k < verSize ; k++){
			if(mat[i][k] == 1 && ver[k].wasVisited == false){
				queue.offer(k);
				//同时更新这些顶点的标记
				//这样做是防止重复放入，放入其中的顶点早晚会被访问
				ver[k].wasVisited = true;
			}
		}
		
		//最后返回更新后的队列
		return queue;
	}
}
~~~

### 邻接表实现

基于邻接表表示一个图ListGraph类。要实现的类与方法：Vertex、ListVex、空参构造、addVertex、addEdge、displayVertex、dfs、bfs、degree

~~~java
class ListGraph{
	
	//顶点数组
	private Vertex[] ver;
	//顶点数组的默认大小
	private static final int DEFAULT_SIZE = 20;
	//size表示图中的顶点数
	private int size;
	//dfs中用的栈
	private Stack<Integer> stack;
	//bfs中用的队列
	private Queue<Integer> queue;
	
	//顶点类
	private static class Vertex{
		//分别代表号、顶点名、顶点标记、第一个邻接结点
		int id;
		String name;
		boolean wasVisited;
		ListVex firstEdge;
				
		//有参构造，默认结点未被访问
		public Vertex(String name){
			this.name = name;
			wasVisited = false;
		}
	}
	
	//邻接链表结点类
	private static class ListVex{
		//结点号和下一个结点指针
		int id;
		ListVex next;
		//有参构造，默认下个结点为空
		public ListVex(int id){
			this.id = id;
			next = null;
		}
	}
	
	//图的初始化，分配一个默认大小的顶点数组
	public ListGraph(){
		ver = new Vertex[DEFAULT_SIZE];
		//将顶点个数初始化为0
		size = 0;
	}
	
	//添加顶点方法
	public void addVertex(String name){
		//将顶点数组的下一个值赋值为新建顶点
		ver[size] = new Vertex(name);
		//此时的size值就赋值为顶点id
		ver[size].id = size;
		//默认新建顶点的第一个邻接结点为空
		ver[size].firstEdge = null;
		//最后顶点数加1
		size++;
	}
	
	//添加边方法，需提供起始id和终止id
	public void addEdge(int begin , int end){
		
		//创建两个结点类为下方操作做准备
		ListVex node;
		ListVex secondNode;
		
		//若输入的起始和终止相同就抛出一个异常
		if(begin == end){
			throw new IllegalStateException();
		}
		
		//第一部分：将起始id对应的邻接链表更新：添加一个包含end信息的结点
		//第一个邻接结点要单独处理，因为firstEdge不能连续向下推进
		//如果第一个邻接结点为空，那么就新建一个邻接结点并将其作为第一结点
		if(ver[begin].firstEdge == null){
			ver[begin].firstEdge = new ListVex(end);
		}else{
			//如果第一个邻接结点不为空，那么就向下推进结点
			//将第一个邻接结点给node，然后令node作为新的邻接结点
			//这样node就成了新的第一结点
			node = ver[begin].firstEdge;
			ver[begin].firstEdge = node;
			//只要node下还有其他节点，就将node赋值为下一个结点
			while(node.next != null){
				node = node.next;
			}
			//直至node没有下一个结点，此时将下一个结点设置为新建的包含end信息的结点
			node.next = new ListVex(end);
			
		}
		
		//第二部分：将终止end对应的邻接链表更新：添加一个包含begin信息的结点
		//这一部分与上一部分是相似的结构
		//因为一条边添加完成一个结点中的链表要有另一个结点的信息，同时另一个结点也要有这个结点的信息
		//所以同样的操作要进行两次
		if(ver[end].firstEdge == null){
			ver[end].firstEdge = new ListVex(begin);
		}else{
			secondNode = ver[end].firstEdge;
			ver[end].firstEdge = secondNode;
			while(secondNode.next != null){
				secondNode = secondNode.next;
			}
			secondNode.next = new ListVex(begin);
		}
	}
		
	//打印某个结点的name
	public void displayVertex(int id){
		System.out.print(ver[id].name + "-->");
	}
	
	//计算度的方法
	public int degree(int id){
		//初始化度为0
		int count = 0;
		//将code记为第id个结点的第一个邻接结点
		ListVex code = ver[id].firstEdge;
		//只要第一结点不为空就把count加一，并继续向后推进
		while(code != null){
			count++;
			code = code.next;
		}
		//循环结束后此时的count值就是度
		return count;
	}
	
	//dfs遍历图，与邻接矩阵实现的dfs遍历相同
	//不同之处仅在于寻找顶点周围下一个可用的顶点方法构造不同
	public void dfs(){
		stack = new Stack<Integer>();
		stack.push(0);
		displayVertex(0);
		ver[0].wasVisited = true;
		while(!stack.empty()){
			//这个方法构造不同
			int j = findNext(stack.peek());
			if(j != -1){
				stack.push(j);
				displayVertex(j);
				ver[j].wasVisited = true;
			}else{
				stack.pop();
			}
		}
		
		for(int i = 0 ; i < size ; i++){
			ver[i].wasVisited = false;
		}
		
		System.out.println("结束");
	}
	
	//该方法用于寻找某个顶点周围可用的顶点号
	private int findNext(int x){
		
		//如果该顶点邻接链表的第一个结点为空，也就是说周围没有其他节点了
		//此时查找失败直接返回-1
		if(ver[x].firstEdge == null){
			return -1;
		}
		
		//如果该顶点邻接链表第一个结点不为空且该顶点没有访问过
		if(ver[ver[x].firstEdge.id].wasVisited == false){
			//返回该顶点号
			return ver[x].firstEdge.id;
		}
		
		//将邻接链表第一个顶点的下一个顶点记为node
		ListVex node = ver[x].firstEdge.next;
		//如果该点不为空就检查是否被方为过，是就返回结点号
		//不是就推进指针，继续查找
		while(node != null){
			if(ver[node.id].wasVisited == false){
				return node.id;
			}else{
				node = node.next;
			}
		}
		
		//循环后如果还没有运行任何return语句那么最后返回-1，查找失败
		return -1;
	}
	
	//bfs遍历图，步骤与邻接矩阵实现图的方法一致
	//唯一不同之处在于将顶点周围所有可用顶点全加入队列的方法构造不同
	public void bfs(){
		queue = new LinkedList<Integer>();
		queue.offer(0);
		ver[0].wasVisited = true;
		while(!queue.isEmpty()){
			//该方法不同
			allInQueue(queue , queue.peek());
			int j = queue.poll();
			displayVertex(j);
		}
		
		for(int i = 0 ; i < size ; i++){
			ver[i].wasVisited = false;
		}
		
		System.out.println("结束");
	}
	
	//该方法用于将某个顶点周围所有可用顶点全加入队列中
	private void allInQueue(Queue<Integer> queue , int x){
		//如果该顶点第一个邻接结点为空，也就是该顶点周围没有顶点
		//此时直接返回
		if(ver[x].firstEdge == null){
			return;
		}
		
		//如果该顶点的第一个邻接结点不为空，且还没有被访问过，就将其加入队列
		//同时更新该顶点的标记，因为加入队列的顶点早晚会访问到
		if(ver[ver[x].firstEdge.id].wasVisited == false){
			queue.offer(ver[x].firstEdge.id);
			ver[ver[x].firstEdge.id].wasVisited = true;
		}
		
		//将第二个邻接结点称为node
		ListVex node = ver[x].firstEdge.next;
		//node只要不为空，就检查他是否被访问过，如果访问过那么就加入队列并更新标志
		//最后还要推进指针继续循环，无论是否有元素加入都要推进指针
		//因为所有的周围顶点都要检查而不是仅加入一个即可
		while(node != null){
			if(ver[node.id].wasVisited == false){
				queue.offer(node.id);
				ver[node.id].wasVisited = true;
			}
			node = node.next;
		}
	}
}
~~~

## 最小生成树

假设你是电信的工程师，需要为一个镇九个村庄架设通信网络做设计，村庄位置和村与村之间的距离如下：

![QQ图片20230104231020](QQ图片20230104231020.png)

领导要求必须用最小的成本完成这次任务。这就是一个典型的构造连通网的最小代价生成树问题，称为最小生成树。满足要求的一定是一个连通图的生成树，它有n个结点，n-1条边组成。下面是几种连接方案及其代价：

![QQ图片20230104231227](QQ图片20230104231227.png)

找连通网的最小生成树，经典的有两种算法：普利姆算法和克鲁斯卡尔算法

### Prim算法

Prim算法的核心思想：将点分为两拨，已经加入最小生成树的，和未加入的。找到未加入中距离集合最近的点，添加该点，修改其它点到集合的距离,直到所有结点都加入到最小生成树。

算法描述如下：

1. 以某一个点A开始，将此点加入集合U，并访问其所有经过此点的边。
2. 在这些边寻找权重最小的边，并且要求它的另一个点B没有被访问过。如果 能找到，就将点B加入集合U。接着我们要访问，所有经过点A或点B的边。
3. 重复2的过程，直到所有的点都加入U。
4. 此时由所有边构成的树即为最小生成树。

prim算法的时间复杂度是O(n2)，其中n是顶点数

下面是一个基于邻接矩阵实现的带权的无向图实现prim算法：

~~~java
//带权的无向图
//与不带权的不同之处：
//1、多了一个域常量，记录边矩阵中的最大值
//2、边矩阵初始化、插入边时有不同
class Weight_MatrixGraph{
	
	//边矩阵中的无穷大
	private static final int INFINITY = 65535;
	//ver代表顶点集合
	private Vertex[] ver;
	//mat代表边矩阵
	private int[][] mat;
	//顶点集合和边矩阵的初始大小
	private static final int DEFAULT_SIZE = 20;
	//verSize代表实际顶点个数
	private int verSize;
	//dfs用的栈
	private Stack<Integer> stack;
	//bfs用的队列
	private Queue<Integer> queue;
	
	//顶点的嵌套类
	private static class Vertex{
		//分别代表顶点名和指示是否遍历过的标志
		String name;
		boolean wasVisited;
		
		//有参构造，默认结点未被初始化
		public Vertex(String name){
			this.name = name;
			wasVisited = false;
		}
	}
	
	//图的无参构造
	public Weight_MatrixGraph(){
		//分别建立边矩阵和顶点集合以默认大小
		ver = new Vertex[DEFAULT_SIZE];
		mat = new int[DEFAULT_SIZE][DEFAULT_SIZE];
		//初始化顶点个数为0
		verSize = 0;
		//遍历边矩阵把各元素初始化
		for(int i = 0 ; i < DEFAULT_SIZE ; i++){
			for(int j = 0 ; j < DEFAULT_SIZE ; j++){
				if(i == j){
					mat[i][j] = 0;
				}else{
					mat[i][j] = INFINITY;
				}
				
			}
		}
	}
	
	//添加顶点
	public void addVertex(String st){
		//将结点添加进入顶点集合中
		ver[verSize] = new Vertex(st);
		//并将顶点个数加1
		verSize++;
	}
	
	//添加边
	public void addEdge(int begin , int end , int weight){
		//不允许添加自己到自己的边
		if(begin == end)return;
		//因为是对称矩阵所以两个数都要初始化
		mat[begin][end] = weight;
		mat[end][begin] = weight;
	}
	
	//打印一个顶点
	public void displayVertex(int i){
		System.out.print(ver[i].name+" ");
	}
	
	//返回顶点的度
	public int degree(int k){
		int degree = 0;
		//遍历边矩阵的一行，对等于1的点计数
		for(int i = 0 ; i < verSize ; i++){
			if(mat[k][i] == 1){
				degree++;
			}
		}
		return degree;
	}
	
	//非递归法借助栈实现dfs
	public void dfs1(){
		//新建栈并把第一个顶点压入栈中
		stack = new Stack<>();
		stack.push(0);
		//打印第一个顶点，也可以做其他操作
		displayVertex(0);
		//把第一个顶点访问标记更新
		ver[0].wasVisited = true;
		
		//循环条件：栈不为空
		//如果栈为空代表遍历结束
		while(!stack.empty()){
			//将栈顶元素拿出放入hasNext方法中获得路径中下一个未访问的顶点
			int j = hasNext(stack.peek());
			//如果该顶点存在
			if(j != -1){
				//将该顶点对应的编号压入栈中
				//打印该顶点并更新标记
				stack.push(j);
				ver[j].wasVisited = true;
				displayVertex(j);
			}else{
				//如果该顶点没有下一个未访问顶点
				//那就将栈弹出，相当于按原路返回寻找新的可能路径
				stack.pop();
			}
		}
		
		//最后更新所有顶点标记做好下一次遍历准备
		for(int k = 0 ; k < verSize ; k++){
			ver[k].wasVisited = false;
		}
	}
	
	//递归法实现dfs
	public void dfs2(){

		//遍历所有顶点调用递归的dfs方法
		//这种递归方式决定了每次找不到下一个点时会尽可能小的寻找新的起始点
		//所以这与栈实现的遍历方式结果不同
		for(int i = 0 ;i < verSize;i++){
			//如果已经遍历过该顶点那么就直接进入下一次循环
			if(ver[i].wasVisited == false){
				dfs(i);
			}
		}
		
		//最后更新所有顶点标记做好下一次遍历准备
		for(int k = 0 ; k < verSize ; k++){
			ver[k].wasVisited = false;
		}
	}
	
	//递归方法
	private void dfs(int i){
		
		//更新标记并打印该顶点
		ver[i].wasVisited = true;
		displayVertex(i);
		
		//获取下一个顶点，如果存在继续递归，不存在结束
		//相当于一条路径走到了尽头，此时返回到上面的for位置
		//继续寻找新顶点
		int j = hasNext(i);
		if(j != -1){
			dfs(j);
		}
	}
	
	//hasNext是判断顶点周围有没有未访问顶点的方法
	private int hasNext(int k){
		
		//遍历周围每一个顶点，相当于遍历边矩阵的一行，如果为1，说明该列号是相邻顶点
		//此时查看该节点，如果没有被访问过，就返回该顶点号
		for(int i = 0;i < verSize;i++){
			if(mat[k][i] == 1 && ver[i].wasVisited == false){
				return i;
			}
		}
		
		//如果遍历结束没有找到未访问顶点，那么返回-1
		return -1;
	}
	
	//bfs遍历图
	public void bfs(){
		//新建一个队列
		queue = new LinkedList<Integer>();
		//将0放入队列中,并将其标志更新
		queue.offer(0);
		ver[0].wasVisited = true;
		
		//循环条件是队列不为空
		while(!queue.isEmpty()){
			//取出队列里的值并打印
			//这里吧更新操作放入了下个方法中
			//因为在更新队列的时候有可能出现重复放入的现象
			//所以要在顶点放入队列的时候把控住
			int j = queue.poll();
			displayVertex(j);
			//将j周围的顶点放入队列中
			queue = takeInQueue(queue , j);
		}
		
		//最后更新所有顶点标记做好下一次遍历准备
		for(int k = 0 ; k < verSize ; k++){
			ver[k].wasVisited = false;
		}
	}
	
	//将周围的顶点放入队列中
	private Queue<Integer> takeInQueue(Queue<Integer> queue , int i){
		
		//遍历边矩阵中的一行，如果有顶点没有被访问就将其放入队列中
		for(int k = 0 ; k < verSize ; k++){
			if(mat[i][k] == 1 && ver[k].wasVisited == false){
				queue.offer(k);
				//同时更新这些顶点的标记
				//这样做是防止重复放入，放入其中的顶点早晚会被访问
				ver[k].wasVisited = true;
			}
		}
		
		//最后返回更新后的队列
		return queue;
	}
	
	//prim方法实现最小生成树
	//该方法以一个顶点为起点，探索它周围的最小权值边，将其纳入生成树中
	//新纳入的节点后再次查找增大范围下最小权边
	//直至所有顶点都纳入最小生成树
	public void prim(){
		//初始化部分，定义变量
		int min , i , j , k = 0;
		//adjvex数组是用来指示下一步位置的数组
		//它的每个值是下一步的起始值，所在位置是下一步的终点值
		int[] adjvex = new int[verSize]; 
		//lowest数组是用来存放每一步可能出现的最小权值的
		//每步其中可能的权值都会更新一次，其中最小的值就是这一步的最优解
		//对应的位置就是下一步的终点值
		int[] lowest = new int[verSize];
		//这个循环用来初始化两个数组，lowest数组被初始化为边矩阵的第一行
		//adjvex数组被全部初始化为0
		//代表第一步我们要从0周围寻找权值最小的结点
		//且此时起始值和终止值都是0
		for(i = 0 ; i < verSize ;i++){
			lowest[i] = mat[0][i];
			adjvex[i] = 0;
		}
		
		
		//循环部分开始，此时两个数组已经完成初始化
		//所以现在只需查找size-1次即可，每一次会打印一个边
		//对应n个结点的最小生成树有n-1条边
		for(i = 1 ; i < verSize ; i++){
			//min值设置为无穷大
			min = INFINITY;
			//这个循环主要用来查找lowest中的最小值，也就是该步的最小权值
			//找到之后把对应的顶点号设置为k，此时k是最小权值边的终点
			//lowest中的0值不能参与最小值比较
			//后面的循环中已经论证了一旦一个元素被设置为0证明其已经加入生成树无需再考虑它了
			//而且一旦lowest中的0值也参与最小值考虑，那么无负权值的情况下每次最小值都是0
			//这个比较也就失去了意义
			for(j = 0 ; j < verSize ; j++){
				if(lowest[j] != 0 && lowest[j] < min){
					min = lowest[j];
					k = j;
				}
			}
			//打印adjvex的k位置和k，也就是最小权值边的起始和终止号
			System.out.print(adjvex[k]+"-->"+k+" ");
			//打印结束后舍弃掉这个最小权值，准备下一次更新
			lowest[k] = 0;
			//这个循环用来寻找k结点周围的最小权值，也就是每增加一个结点都要把它的最小权值更新进lowest
			//同时把k放进adjvex对应更新的位置，这表示从当前情形出发到各位置的最小权值更新了
			//k表示到这个位置是从k结点出发，当然此时adjvex数组中还有出来k以外其他值
			//这些值没有被更新说明k的加入只改变了一部分到各点值的最优权值
			//而adjvex只有size个位置却能记录下下一步的位置是因为
			//就特殊的每一步而言，到每点的最小权值是固定的，随着生成树的增大，
			//权值在降低，出发点在改变
			for(j = 0 ; j < verSize ; j++){
				//lowest为0的位置不能参与更新，这是因为一旦该位置为0就意味着该顶点已经被纳入生成树中
				//无需再计算到达它的最小代价了
				//lowest一开始初始化时0位置就是0，这代表0顶点为起点
				//而后每一次进行下列循环都会不可避免的将边矩阵中的0值覆盖掉lowest中的一个值
				//因为边矩阵中每一行一定有一个元素为0，这代表自己到自己的权值为0
				//这个位置一定是k，表明k结点已加入最小生成树
				if(lowest[j]!= 0 && mat[k][j] < lowest[j]){
					lowest[j] = mat[k][j];
					adjvex[j] = k;
				}
			}
			//lowest到最后是一个全部为0的数组，这代表所有顶点都已经加入生成树
			//最小生成树已经查找完成
		}
	}
}
~~~

### Kruskal算法

假设一个图有m个节点，n条边。首先，我们需要把m个节点看成m个独立的生成树，并且把n条边按照从小到大的数据进行排列。在n条边中，我们依次取出其中的每一条边，如果发现边的两个节点分别位于两棵树上，那么把两棵树合并成为一颗树；如果树的两个节点位于同一棵树上，那么忽略这条边，继续运行。等到所有的边都遍历结束之后，如果所有的生成树可以合并成一条生成树，那么它就是我们需要寻找的最小生成树，反之则没有最小生成树。

总的来说，Prim算法是以点为对象，挑选与点相连的最短边来构成最小生成树。而Kruskal算法是以边为对象，不断地加入新的不构成环路的最短边来构成最小生成树。

Kruskal算法的时间复杂度是O(eloge)，其中e是边数。Prim算法对于稠密图效果会很好，Kruskal算法更适合稀疏图。

下面是一个基于边集数组的无向图实现kruskal算法：

~~~java
class Weight_ArrayGraph{
	
	//ver代表顶点集合
	private Vertex[] ver;
	//mat代表边矩阵
	private edge[] edgeArray;
	//顶点集合和边矩阵的初始大小
	private static final int VER_DEFAULT_SIZE = 20;
	//边集数组大小
	private static final int EDGE_DEFAULT_SIZE = 40;
	//verSize代表实际顶点个数
	private int verSize;
	//edgeCount代表边的数量
	private int edgeCount;
	
	//顶点的嵌套类
	private static class Vertex{
		//分别代表顶点名和指示是否遍历过的标志
		String name;
		boolean wasVisited;
		
		//有参构造，默认结点未被初始化
		public Vertex(String name){
			this.name = name;
			wasVisited = false;
		}
	}
	
	//边集数组的边节点类
	private static class edge{
		//域中有起始顶点号、终止顶点号、权
		int beginId;
		int endId;
		int weight;
		public edge(int beginId, int endId, int weight) {
			super();
			this.beginId = beginId;
			this.endId = endId;
			this.weight = weight;
		}
	}
	
	//添加顶点
	public void addVertex(String st){
		//将结点添加进入顶点集合中
		ver[verSize] = new Vertex(st);
		//并将顶点个数加1
		verSize++;
	}
	
	//添加边
	public void addEdge(int begin , int end , int weight){
		
		//如果边的起始或终止顶点还没有添加到顶点集合中就抛出一个异常
		if(begin >= verSize||end >= verSize){
			throw new IllegalStateException();
		}
		
		//将新建的边加入边集数组
		edgeArray[edgeCount] = new edge(begin , end , weight);
		//边数加一
		edgeCount++;
	}

	//图类的无参构造
	//初始化顶点集合和边集数组，并使顶点个数和边个数归零
	public Weight_ArrayGraph() {
		super();
		ver = new Vertex[VER_DEFAULT_SIZE];
		edgeArray = new edge[EDGE_DEFAULT_SIZE];
		verSize = 0;
		edgeCount = 0;
	}
	
	//将边集数组按权值从小到大排序
	public void sortEdgeArray(){
		
		if(edgeCount == 0 || edgeCount == 1){
			return;
		}
		
		edge shift = null;
		for(int i = 0 ; i < edgeCount -1 ;i++){
			for(int j = i ; j < edgeCount - 1 ; j++){
				if(edgeArray[i].weight > edgeArray[j+1].weight){
					shift = edgeArray[i];
					edgeArray[i] = edgeArray[j+1];
					edgeArray[j+1] = shift;
				}
			}
		}
	}
	
	//打印一条边
	public void printEdge(){
		for(int i = 0 ; i < edgeCount ; i++){
			System.out.print(edgeArray[i].weight+" ");
		}
	}
	
	//kruskal算法实现最小生成树
	//这种算法依次将权最小的边纳入生成树中，如果这个过程中形成环则舍弃不要
	//最后有且只有一种结果就是最小生成树
	//形成最小生成树后添加任意的边都会形成环，因为此时树已经包含了全部n个顶点
	//最后方法结束
	public void kruskal(){
		//初始化准备部分，定义m、n
		//endNode是一个记载顶点的终点值的数组，它的大小与顶点数组相同
		//endNode被全部初始化为0
		int m , n;
		int[] endNode = new int[verSize];
		for(int i = 0 ; i < verSize ; i++){
			endNode[i] = 0;
		}
		
		//循环部分开始，循环次数与边的个数相同，每次循环都决定边集数组对应的边到底是
		//加入生成树还是不加入
		for(int i = 0 ; i < edgeCount ; i++){
			//m值代表待判定边begin的终点顶点号
			m = findEnd(endNode , edgeArray[i].beginId);
			//n值代表待判定边end的终点顶点号
			n = findEnd(endNode , edgeArray[i].endId);
			//若m与n不相等，说明该边可以加入生成树，打印该边
			//若m与n相等，说明待判定边的两端拥有同一个终点值，这会形成回环，破坏生成树的结构
			//故此时不加入
			//终点值是指连成树结构的各顶点拥有同一个终点值，这个顶点的号码就是终点值
			//如果待判定的两边拥有同一个终点值，这说明这两端都在已有的生成树中，显然会形成回环
			//如果两端在两个不同的生成树中，if结束后这两个生成树便会合并成一个
			//此时连成一片的新生成树也只有一个终点值
			//当然如果两端都不在已有的生成树中也可以，相当于建立了新的子树
			if(m != n){
				//下一句代表m顶点会以n为下一个终点
				//n自己也可以有终点，n的最后一个终点就是m和n的最终终点
				endNode[m] = n;
				//打印生成树的边，说明该边就是最小生成树的一部分
				System.out.print(edgeArray[i].beginId+"-->"+edgeArray[i].endId+" ");
				//在刚开始endNode全是0，随着各位置数字的更新0逐渐变少
				//最终的endNode只有一个位置是0，在接下来的寻找终点的方法中可以看到
				//0代表查找的终点，也就是最后生成树只能有一个终点，也就是所有的子树已经连成片
				//且其中没有环
				//在0逐渐变少的过程中，endNode数组各点之间逐渐产生联系，最后将终点指向其中一个位置
			}
		}
	}

	//寻找顶点的终点的方法
	private int findEnd(int[] endNode, int Id) {
		//如果endNode对应位置不为0，那么就把该位置的值覆盖到id
		//下次在endNode查找的新id就是上个位置数组的值
		//通过这样的机制使数组各位置形成类似指针的结构
		while(endNode[Id] != 0){
			Id = endNode[Id];
		}
		//直至下个指向0，停止，返回id的值，也就是顶点的终点值
		return Id;
		//这种巧妙的设计使得所有连成片的生成树有且只有一个顶点值
	}
}
~~~

## 最短路径

在网图和非网图中，最短路径的含义是不同的：

* 非网图的最短路径其实就是指两顶点之间经过的边数最少的路径
* 对于网图来说，最短路径是指两顶点之间经过的边上权值之和最少的路径，并且我们称路径上的第一个顶点是源点，最后一个顶点是终点

非网图完全可以理解为所有边的权值都是1的网图。

### Dijkstra算法

迪杰斯特拉算法的大体思路如下

假设v1为源点，找从v1到其它节点的最短路径：

![QQ图片20230105233940](QQ图片20230105233940.png)

用一个集合S来存储v1到各点的最短路径，最终该算法返回的结果就是集合S。

v1到自己显然最短，故为初始最短路径：

|  步骤  |  S   |  v2  |  v3  |  v4  |  v5  |  v6  |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  1   |  v1  |      |      |      |      |      |

第一轮：从v1出发，计算v1到其它节点的距离：

|  步骤  |  S   |  v2  |  v3  |  v4  |  v5  |  v6  |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  1   |  v1  |  10  |      |      |      |  3   |

全表找最小值，发现v1到v6最短为3，然后S中添加一条最短路径：v1——v6，同时到v6的距离已经算出来了，最少就是3（不可能比3更小了），后续也不用更新v6列的距离了。

第二轮：从v1——v6出发，计算v1通过v6到其它节点的距离

已知v1到v6为3；v6可以到v2,v4,v5；因此，v1通过v6到其它节点的距离为3+n，n为6到各节点的距离

|  步骤  |   S    |  v2  |  v3  |  v4  |  v5  |  v6  |
| :--: | :----: | :--: | :--: | :--: | :--: | :--: |
|  1   |   v1   |  10  |      |      |      |  3   |
|  2   | v1——v6 |  5   |      |  9   |  4   |      |

在全表中找最小值（v6列已经删除），此时4为最小值，对应路径v1——v6——v5

添加最短路径v1——v6——v5，同时v5列不再考虑

第三轮：从v1——v6——v5出发，计算v1通过v6及v5到其它节点的距离：发现5不能到任何结点，所以继续找最小值5，对应的路径是v1——v6——v2，添加最短路径v1——v6——v2，同时v2列不再考虑

|  步骤  |     S      |  v2  |  v3  |  v4  |  v5  |  v6  |
| :--: | :--------: | :--: | :--: | :--: | :--: | :--: |
|  1   |     v1     |  10  |      |      |      |  3   |
|  2   |   v1——v6   |  5   |      |  9   |  4   |      |
|  3   | v1——v6——v5 |      |      |      |      |      |
|  4   | v1——v6——v2 |      |  12  |  10  |      |      |

第四轮：遍历全表（v2，v5和v6已经删除）发现，9最小，对应的路径为v1——v6——v4，同时v4列不再考虑

|  步骤  |     S      |  v2  |  v3  |  v4  |  v5  |  v6  |
| :--: | :--------: | :--: | :--: | :--: | :--: | :--: |
|  1   |     v1     |  10  |      |      |      |  3   |
|  2   |   v1——v6   |  5   |      |  9   |  4   |      |
|  3   | v1——v6——v5 |      |      |      |      |      |
|  4   | v1——v6——v2 |      |  12  |  10  |      |      |
|  5   | v1——v6——v4 |      |  13  |      |      |      |

第五轮：遍历全表发现，12是现存的最小值，对应v1——v6——v2——v3路径最短，同时v3列不考虑。由于v3不到任何点，所以最终的表格如下

|  步骤  |       S        |  v2  |  v3  |  v4  |  v5  |  v6  |
| :--: | :------------: | :--: | :--: | :--: | :--: | :--: |
|  1   |       v1       |  10  |      |      |      |  3   |
|  2   |     v1——v6     |  5   |      |  9   |  4   |      |
|  3   |   v1——v6——v5   |      |      |      |      |      |
|  4   |   v1——v6——v2   |      |  12  |  10  |      |      |
|  5   |   v1——v6——v4   |      |  13  |      |      |      |
|  6   | v1——v6——v2——v3 |      |      |      |      |      |

全部列的最小值都已经固定，所以v1到各节点的路径及其最短距离：

v2：v1——v6——v2 = 5
v3：v1——v6——v2——v3 = 12
v4：v1——v6——v4 = 9
v5：v1——v6——v5 = 4
v6：v1——v6 = 3

Dijkstra算法是一种基于贪心策略的算法。每次新扩展一个路程最短的点，更新与其相邻的点的路程。当所有边权都为正时，由于不会存在一个路程更短的没扩展过的点，所以这个点的路程永远不会再被改变，因而保证了算法的正确性。

根据这个原理，用Dijkstra算法求最短路径的图不能有负权边，因为扩展到负权边的时候会产生更短的路径，有可能破坏了已经更新的点路径不会发生改变的性质。

Dijkstra算法解决了从某个源点到其余各顶点的最短路径问题，时间复杂度是On2，其中n是顶点数，而且要得到某一个具体的终点的最短路径，也要遍历所有n个点才可以。如果想要得到任意一个源点到其余所有顶点的最短路径，需要在此基础上再套一层循环，遍历一遍所有顶点，此时时间复杂度为On3

### Floyd算法

它可以求所有顶点到所有顶点的最短路径，时间复杂度是On3

从出发地到目的地的过程中，我们并不是一下子就到达目的地，而是要经过很多的中转站来帮助我们一步一步地到达目的地。例如下面的图中，假设 AB，BC 之间的距离分别为 7 和 2。我们看到，A 和 C 之间不能直接通达，因此，要计算 A 和 C 之间的距离，我们就要借助 B 来作为中转站，因此 A 到 C 的距离为 7 + 2 = 9。

![QQ图片20230106225009](QQ图片20230106225009.png)

因此，计算所有节点之间的最短距离这个大问题可以分为借助k个中转站的情况下计算各节点之间的最短路径。

下面来谈一下具体的求解过程，我们首先用邻接矩阵来表示这张图，其中无限符号表示两个节点之间不能相互直达，矩阵中每一项的数字代表边的权重，也就是节点之间的距离：

![QQ图片20230106225119](QQ图片20230106225119.png)

上面的矩阵也可以代表在不借助中转站的情况下（ k=0 ）各节点之间的最短路径。接下来，我们只让节点 A 作为中转站，然后计算各节点的最短路径，然后对于矩阵的每一项，我们比较d\[i][j]和d\[i][1]+d\[1][j]的大小，然后取最小者作为d\[i][j]的值。其中i和j分别代表矩阵的行和列。

![QQ图片20230106225229](QQ图片20230106225229.png)

计算后我们发现矩阵中的第 2 行第 5 列变成了8，说明从节点 B 到节点 E 的最短距离在当前状态下为  。接下来，我们逐渐增加中转站的个数，每增加一个中转站的个数，矩阵就更新一次。k从1递增到n，每递增一次，矩阵的值就更新一次，最后我们就得到所有点对的最短距离了。

用代码表示这个过程非常简单，只需要几行就能实现：

~~~
def Floyd(d):
    n = d.shape[0]
    for k in range(n):
        for i in range(n):
            for j in range(n):
                d[i][j] = min(d[i][j], d[i][k]+d[k][j])
    return d
~~~

### 代码实现

基于邻接矩阵实现的带权无向图，实现查找最小路径的Dijkstra算法、以及Floyd算法：

~~~java
//带权的无向图
//与不带权的不同之处：
//1、多了一个域常量，记录边矩阵中的最大值
//2、边矩阵初始化、插入边时有不同
class Weight_MatrixGraph_2{
	
	//边矩阵中的无穷大
	private static final int INFINITY = 65535;
	//ver代表顶点集合
	private Vertex[] ver;
	//mat代表边矩阵
	private int[][] mat;
	//顶点集合和边矩阵的初始大小
	private static final int DEFAULT_SIZE = 20;
	//verSize代表实际顶点个数
	private int verSize;
	//dfs用的栈
	private Stack<Integer> stack;
	//bfs用的队列
	private Queue<Integer> queue;
	
	//顶点的嵌套类
	private static class Vertex{
		//分别代表顶点名和指示是否遍历过的标志
		String name;
		boolean wasVisited;
		
		//有参构造，默认结点未被初始化
		public Vertex(String name){
			this.name = name;
			wasVisited = false;
		}
	}
	
	//图的无参构造
	public Weight_MatrixGraph_2(){
		//分别建立边矩阵和顶点集合以默认大小
		ver = new Vertex[DEFAULT_SIZE];
		mat = new int[DEFAULT_SIZE][DEFAULT_SIZE];
		//初始化顶点个数为0
		verSize = 0;
		//遍历边矩阵把各元素初始化
		for(int i = 0 ; i < DEFAULT_SIZE ; i++){
			for(int j = 0 ; j < DEFAULT_SIZE ; j++){
				if(i == j){
					mat[i][j] = 0;
				}else{
					mat[i][j] = INFINITY;
				}
				
			}
		}
	}
	
	//添加顶点
	public void addVertex(String st){
		//将结点添加进入顶点集合中
		ver[verSize] = new Vertex(st);
		//并将顶点个数加1
		verSize++;
	}
	
	//添加边
	public void addEdge(int begin , int end , int weight){
		//不允许添加自己到自己的边
		if(begin == end)return;
		//因为是对称矩阵所以两个数都要初始化
		mat[begin][end] = weight;
		mat[end][begin] = weight;
	}
	
	//打印一个顶点
	public void displayVertex(int i){
		System.out.print(ver[i].name+" ");
	}
	
	//返回顶点的度
	public int degree(int k){
		int degree = 0;
		//遍历边矩阵的一行，对等于1的点计数
		for(int i = 0 ; i < verSize ; i++){
			if(mat[k][i] == 1){
				degree++;
			}
		}
		return degree;
	}
	
	//非递归法借助栈实现dfs
	public void dfs1(){
		//新建栈并把第一个顶点压入栈中
		stack = new Stack<>();
		stack.push(0);
		//打印第一个顶点，也可以做其他操作
		displayVertex(0);
		//把第一个顶点访问标记更新
		ver[0].wasVisited = true;
		
		//循环条件：栈不为空
		//如果栈为空代表遍历结束
		while(!stack.empty()){
			//将栈顶元素拿出放入hasNext方法中获得路径中下一个未访问的顶点
			int j = hasNext(stack.peek());
			//如果该顶点存在
			if(j != -1){
				//将该顶点对应的编号压入栈中
				//打印该顶点并更新标记
				stack.push(j);
				ver[j].wasVisited = true;
				displayVertex(j);
			}else{
				//如果该顶点没有下一个未访问顶点
				//那就将栈弹出，相当于按原路返回寻找新的可能路径
				stack.pop();
			}
		}
		
		//最后更新所有顶点标记做好下一次遍历准备
		for(int k = 0 ; k < verSize ; k++){
			ver[k].wasVisited = false;
		}
	}
	
	//递归法实现dfs
	public void dfs2(){

		//遍历所有顶点调用递归的dfs方法
		//这种递归方式决定了每次找不到下一个点时会尽可能小的寻找新的起始点
		//所以这与栈实现的遍历方式结果不同
		for(int i = 0 ;i < verSize;i++){
			//如果已经遍历过该顶点那么就直接进入下一次循环
			if(ver[i].wasVisited == false){
				dfs(i);
			}
		}
		
		//最后更新所有顶点标记做好下一次遍历准备
		for(int k = 0 ; k < verSize ; k++){
			ver[k].wasVisited = false;
		}
	}
	
	//递归方法
	private void dfs(int i){
		
		//更新标记并打印该顶点
		ver[i].wasVisited = true;
		displayVertex(i);
		
		//获取下一个顶点，如果存在继续递归，不存在结束
		//相当于一条路径走到了尽头，此时返回到上面的for位置
		//继续寻找新顶点
		int j = hasNext(i);
		if(j != -1){
			dfs(j);
		}
	}
	
	//hasNext是判断顶点周围有没有未访问顶点的方法
	private int hasNext(int k){
		
		//遍历周围每一个顶点，相当于遍历边矩阵的一行，如果为1，说明该列号是相邻顶点
		//此时查看该节点，如果没有被访问过，就返回该顶点号
		for(int i = 0;i < verSize;i++){
			if(mat[k][i] == 1 && ver[i].wasVisited == false){
				return i;
			}
		}
		
		//如果遍历结束没有找到未访问顶点，那么返回-1
		return -1;
	}
	
	//bfs遍历图
	public void bfs(){
		//新建一个队列
		queue = new LinkedList<Integer>();
		//将0放入队列中,并将其标志更新
		queue.offer(0);
		ver[0].wasVisited = true;
		
		//循环条件是队列不为空
		while(!queue.isEmpty()){
			//取出队列里的值并打印
			//这里吧更新操作放入了下个方法中
			//因为在更新队列的时候有可能出现重复放入的现象
			//所以要在顶点放入队列的时候把控住
			int j = queue.poll();
			displayVertex(j);
			//将j周围的顶点放入队列中
			queue = takeInQueue(queue , j);
		}
		
		//最后更新所有顶点标记做好下一次遍历准备
		for(int k = 0 ; k < verSize ; k++){
			ver[k].wasVisited = false;
		}
	}
	
	//将周围的顶点放入队列中
	private Queue<Integer> takeInQueue(Queue<Integer> queue , int i){
		
		//遍历边矩阵中的一行，如果有顶点没有被访问就将其放入队列中
		for(int k = 0 ; k < verSize ; k++){
			if(mat[i][k] == 1 && ver[k].wasVisited == false){
				queue.offer(k);
				//同时更新这些顶点的标记
				//这样做是防止重复放入，放入其中的顶点早晚会被访问
				ver[k].wasVisited = true;
			}
		}
		
		//最后返回更新后的队列
		return queue;
	}
	
	//prim方法实现最小生成树
	//该方法以一个顶点为起点，探索它周围的最小权值边，将其纳入生成树中
	//新纳入的节点后再次查找增大范围下最小权边
	//直至所有顶点都纳入最小生成树
	public void prim(){
		//初始化部分，定义变量
		int min , i , j , k = 0;
		//adjvex数组是用来指示下一步位置的数组
		//它的每个值是下一步的起始值，所在位置是下一步的终点值
		int[] adjvex = new int[verSize]; 
		//lowest数组是用来存放每一步可能出现的最小权值的
		//每步其中可能的权值都会更新一次，其中最小的值就是这一步的最优解
		//对应的位置就是下一步的终点值
		int[] lowest = new int[verSize];
		//这个循环用来初始化两个数组，lowest数组被初始化为边矩阵的第一行
		//adjvex数组被全部初始化为0
		//代表第一步我们要从0周围寻找权值最小的结点
		//且此时起始值和终止值都是0
		for(i = 0 ; i < verSize ;i++){
			lowest[i] = mat[0][i];
			adjvex[i] = 0;
		}
		
		
		//循环部分开始，此时两个数组已经完成初始化
		//所以现在只需查找size-1次即可，每一次会打印一个边
		//对应n个结点的最小生成树有n-1条边
		for(i = 1 ; i < verSize ; i++){
			//min值设置为无穷大
			min = INFINITY;
			//这个循环主要用来查找lowest中的最小值，也就是该步的最小权值
			//找到之后把对应的顶点号设置为k，此时k是最小权值边的终点
			//lowest中的0值不能参与最小值比较
			//后面的循环中已经论证了一旦一个元素被设置为0证明其已经加入生成树无需再考虑它了
			//而且一旦lowest中的0值也参与最小值考虑，那么无负权值的情况下每次最小值都是0
			//这个比较也就失去了意义
			for(j = 0 ; j < verSize ; j++){
				if(lowest[j] != 0 && lowest[j] < min){
					min = lowest[j];
					k = j;
				}
			}
			//打印adjvex的k位置和k，也就是最小权值边的起始和终止号
			System.out.print(adjvex[k]+"-->"+k+" ");
			//打印结束后舍弃掉这个最小权值，准备下一次更新
			lowest[k] = 0;
			//这个循环用来寻找k结点周围的最小权值，也就是每增加一个结点都要把它的最小权值更新进lowest
			//同时把k放进adjvex对应更新的位置，这表示从当前情形出发到各位置的最小权值更新了
			//k表示到这个位置是从k结点出发，当然此时adjvex数组中还有出来k以外其他值
			//这些值没有被更新说明k的加入只改变了一部分到各点值的最优权值
			//而adjvex只有size个位置却能记录下下一步的位置是因为
			//就特殊的每一步而言，到每点的最小权值是固定的，随着生成树的增大，
			//权值在降低，出发点在改变
			for(j = 0 ; j < verSize ; j++){
				//lowest为0的位置不能参与更新，这是因为一旦该位置为0就意味着该顶点已经被纳入生成树中
				//无需再计算到达它的最小代价了
				//lowest一开始初始化时0位置就是0，这代表0顶点为起点
				//而后每一次进行下列循环都会不可避免的将边矩阵中的0值覆盖掉lowest中的一个值
				//因为边矩阵中每一行一定有一个元素为0，这代表自己到自己的权值为0
				//这个位置一定是k，表明k结点已加入最小生成树
				if(lowest[j]!= 0 && mat[k][j] < lowest[j]){
					lowest[j] = mat[k][j];
					adjvex[j] = k;
				}
			}
			//lowest到最后是一个全部为0的数组，这代表所有顶点都已经加入生成树
			//最小生成树已经查找完成
		}
	}
	
	//Dijkstra算法查找最短路径
	//参数pathArray代表一个顶点数为大小的int数组，在完成方法后它是指示路径的数组
	//[0, 0, 1, 4, 2, 4, 3, 6, 7]表示8的前驱结点是7,7的前驱结点是6,6的前驱结点是3，直到0
	//再反过来就是顺序的路径
	//参数weightArray代表一个顶点数为大小的int数组，完成方法后它代表通往各点的最小权重
	//[0, 1, 4, 7, 5, 8, 10, 12, 16]表示0通往各点的最小权重分别是1、4、7、5、8、10、12、16
	//Dijkstra算法的运行过程：从起始结点开始寻找离该节点最近的一个结点，并同时把新增结点的周围路径长度
	//更新一遍，更新后再寻找新组成的复合结点的最近结点，直至所有节点都找到，每次循环在路径中加入一个结点
	//这样最后就能得到最短路径
	public void Dijkstra(int[] pathArray , int[] weightArray){
		//初始化部分，初始化k,min
		int  k = 0 , min = 0;
		//finalSign是一个标记到该节点的最短路径确定还是没确定的标记数组
		//它的大小是结点数
		boolean[] finalSign = new boolean[verSize];
		//用一个循环将三个数组初始化
		//weightArray被初始化为边矩阵的第一行，也就是0结点到其他节点的距离，如果起始点不在0也可以
		//finalSign被初始化全为false，意思是刚开始没有任何结点的最短路径确定了
		//pathArray被初始化为0
		for(int i = 0 ; i < verSize ; i++){
			weightArray[i] = mat[0][i];
			finalSign[i] = false;
			pathArray[i] = 0;
		}
		
		//weightArray的零位置被赋值为0，代表0到0路径长为0，起始点不在0也可以
		weightArray[0] = 0;
		//finalSign的零位置被赋值为true，代表到0结点的最短路径确定了，起始点不在0也可以
		finalSign[0] = true;
		
		//循环开始，共还有n-1个结点待加入，故循环n-1次
		//这个算法一次性把到所有节点的最短路径都确定了，一般不能特定指明求哪个
		//因为算法本身的机制决定了必须循环尽可能多的点，才能获得到某点的路径最小值
		for(int i = 1 ; i < verSize ; i++){
			//初始化最小值min
			min = INFINITY;
			//这个循环用来查找0节点到其他节点的路径里哪条最短
			for(int j = 0 ; j < verSize ; j++ ){
				//finalSign对应位置标记为true不能进入循环，因为此时该路径值已经固定了
				//只在未确定的节点路径长度里选择最小的路径
				if(finalSign[j] == false && weightArray[j] < min){
					min = weightArray[j];
					//用k来记录这个最小值的位置，实际上就是能确定的最短路径的终点
					k = j;
				}
			}
			//此时相当于把到k点的路径长度确定了，此时确定的值一定是到k的最短路径
			//因为此时到其他路径的值都比这个值大，通过走其他路径再绕回的想法不能实现了
			finalSign[k] = true;
			//下面这个循环用来把新加入的k结点可到达的结点路径长度更新一遍
			for(int j = 0 ; j < verSize ; j++){
				//如果k到达他周围的点比原来weightArray数组中到该点的代价更小，那么就用这个更短的路径
				//同样的finalSign对应位置标记为true不能进入循环
				//min + mat[k][j]相当于先到k点在从k到j点的路径长度
				if(finalSign[j] == false && min + mat[k][j] < weightArray[j]){
					weightArray[j] = min + mat[k][j];
					//此时如果被更新说明当前到j的最短路径一定是途径k结点的
					//相当于此时j的前驱结点是k
					//最后pathArray数组记载了到达各结点最短路径的路径信息
					pathArray[j] = k;
					//每次循环都有finalSign都有一个位置被设置为true
					//n-1次后所有的finalSign都为true，也就相当于所有节点的路径最小值都确定了
				}
			}
		}
	}
	
	//Floyd算法计算任意两点的最短路径
	//参数weightArray、pathArray是一个以顶点个数为边长的矩阵
	//运行结束后weightArray存着i结点到j结点的路径最小值,它的第一行就是0到各点的路径最小值
	//pathArray存有各点之间的最短路径，运行后的pathArray矩阵：
	/*[0, 1, 1, 1, 1, 1, 1, 1, 1]
	  [0, 1, 2, 2, 2, 2, 2, 2, 2]
	  [1, 1, 2, 4, 4, 4, 4, 4, 4]
      [4, 4, 4, 3, 4, 4, 6, 6, 6]
	  [2, 2, 2, 3, 4, 5, 3, 3, 3]
	  [4, 4, 4, 4, 4, 5, 7, 7, 7]
	  [3, 3, 3, 3, 3, 7, 6, 7, 7]
	  [6, 6, 6, 6, 6, 5, 6, 7, 8]
	  [7, 7, 7, 7, 7, 7, 7, 7, 8]
	  如果要计算0到8的路径应该这样操作：检查08点是1，再检查18点是2，在检查28点是4，检查48点直至到88点
	  所有的曾经用过的行号就是路径本身*/
	//Floyd算法的机制在于以某点k为中间路径，如果从i到k的距离加k到j的距离比i到j的距离小就替换掉它
	//逐步更新下来最后剩下的路径就都是最小值
	//这种算法一次性把所有点之间的最小路径都算出来了，比Dijkstra更耗时也更强大
	public void Floyd(int[][] weightArray , int[][] pathArray ){
		//初始化两个矩阵
		for(int i = 0; i < verSize ; i++){
			for(int j = 0; j < verSize ; j++){
				//初始化的weightArray矩阵就跟边矩阵完全相同
				weightArray[i][j] =  mat[i][j];
				//这代表初始的pathArray矩阵路径都是直接的，任何点到任何点都是一步到位
				pathArray[i][j] = j;
			}
		}
		//三重嵌套，以中转结点k为第一层，要修改的元素位置也就是路径i、j为第二、三层
		for(int k = 0 ;k < verSize;k++){
			for(int i = 0 ; i < verSize ; i++){
				for(int j = 0 ; j < verSize ; j++){
					if(weightArray[i][j] > weightArray[i][k] + weightArray[k][j]){
						weightArray[i][j] = weightArray[i][k] + weightArray[k][j];
						//如果该路径被更新，那么pathArray也要更新它的值
						//这代表从i到j的路径必须先从i到k
						pathArray[i][j] = pathArray[i][k];
					}
				}
			}
		}
	}
}
~~~

## 拓扑排序

在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系，这样的有向图为顶点表示活动的网，称为AOV网（Activity On Vertex Network）。

AOV网中的弧表示活动之间存在的某种制约关系，必须完成活动A，才可以完成活动B。

AOV网中不能存在回路，某个活动的开始要以自己完成作为先决条件是不可能的。

![QQ图片20230106225858](QQ图片20230106225858.png)

在AOV网中的有序顶点序列就是拓扑序列，AOV网中的拓扑序列不止一条。所谓拓扑排序其实就是对一个有向图构造拓扑序列的过程。

构造拓扑序列时会有两种结果：

* 此网的全部顶点都被输出，则说明它是不存在环的AOV网
* 此网的输出顶点少了，哪怕是少了一个，也说明这个网存在环，不是AOV网

对AOV网进行拓扑排序的思路是：从AOV网中选择一个入度为0的顶点输出，然后删去此顶点，并删除以此顶点为尾的弧，继续重复此步骤，直到输出全部顶点或者AOV网中不存在入度为0的顶点为止。

由于拓扑排序需要删除顶点，所以用邻接表来表示图会更方便。考虑到算法过程中始终要查找入度为0的顶点，所以在节点结构中特意增加了一个入度域。

在算法过程中需要一个栈作为辅助，每次变化时都会将入度为0的结点压入栈中，循环从栈中取，等到栈为空算法也就结束了。

对一个具有n个顶点e条弧的AOV网来说，算法时间复杂度是O(n+e)

~~~java
//它与寻常链表实现的图不同之处之一在于每个顶点都附加了一个叫入度的域
//每次添加边的时候会将end处的顶点入度加1
//添加边时不在像无向边一样在两头添加，只在一头添加
class AOV_ListGraph{
	
	//顶点数组
	private Vertex[] ver;
	//顶点数组的默认大小
	private static final int DEFAULT_SIZE = 20;
	//size表示图中的顶点数
	private int size;
	//dfs中用的栈
	private Stack<Integer> stack;
	//bfs中用的队列
	private Queue<Integer> queue;
	
	//顶点类
	private static class Vertex{
		//分别代表号、顶点名、顶点标记、第一个邻接结点
		int id;
		String name;
		boolean wasVisited;
		ListVex firstEdge;
		//顶点的入度
		int inDegree;
				
		//有参构造，默认结点未被访问
		public Vertex(String name){
			this.name = name;
			wasVisited = false;
			inDegree = 0;
		}
	}
	
	//邻接链表结点类
	private static class ListVex{
		//结点号和下一个结点指针
		int id;
		ListVex next;
		//有参构造，默认下个结点为空
		public ListVex(int id){
			this.id = id;
			next = null;
		}
	}
	
	//图的初始化，分配一个默认大小的顶点数组
	public AOV_ListGraph(){
		ver = new Vertex[DEFAULT_SIZE];
		//将顶点个数初始化为0 
		size = 0;
	}
	
	//添加顶点方法
	public void addVertex(String name){
		//将顶点数组的下一个值赋值为新建顶点
		ver[size] = new Vertex(name);
		//此时的size值就赋值为顶点id
		ver[size].id = size;
		//默认新建顶点的第一个邻接结点为空
		ver[size].firstEdge = null;
		//最后顶点数加1
		size++;
	}
	
	//添加边方法，需提供起始id和终止id
	public void addEdge(int begin , int end){
		
		//创建两个结点类为下方操作做准备
		ListVex node;
		ListVex secondNode;
		
		//若输入的起始和终止相同就抛出一个异常
		if(begin == end){
			throw new IllegalStateException();
		}
		
		//第一部分：将起始id对应的邻接链表更新：添加一个包含end信息的结点
		//第一个邻接结点要单独处理，因为firstEdge不能连续向下推进
		//如果第一个邻接结点为空，那么就新建一个邻接结点并将其作为第一结点
		if(ver[begin].firstEdge == null){
			ver[begin].firstEdge = new ListVex(end);
		}else{
			//如果第一个邻接结点不为空，那么就向下推进结点
			//将第一个邻接结点给node，然后令node作为新的邻接结点
			//这样node就成了新的第一结点
			node = ver[begin].firstEdge;
			ver[begin].firstEdge = node;
			//只要node下还有其他节点，就将node赋值为下一个结点
			while(node.next != null){
				node = node.next;
			}
			//直至node没有下一个结点，此时将下一个结点设置为新建的包含end信息的结点
			node.next = new ListVex(end);
		}
		//终止顶点的入度加1
		ver[end].inDegree++;
	}
		
	//打印某个结点的name
	public void displayVertex(int id){
		System.out.print(ver[id].name + "-->");
	}
	
	//计算度的方法
	public int degree(int id){
		//初始化度为0
		int count = 0;
		//将code记为第id个结点的第一个邻接结点
		ListVex code = ver[id].firstEdge;
		//只要第一结点不为空就把count加一，并继续向后推进
		while(code != null){
			count++;
			code = code.next;
		}
		//循环结束后此时的count值就是度
		return count;
	}
	
	//dfs遍历图，与邻接矩阵实现的dfs遍历相同
	//不同之处仅在于寻找顶点周围下一个可用的顶点方法构造不同
	public void dfs(){
		stack = new Stack<Integer>();
		stack.push(0);
		displayVertex(0);
		ver[0].wasVisited = true;
		while(!stack.empty()){
			//这个方法构造不同
			int j = findNext(stack.peek());
			if(j != -1){
				stack.push(j);
				displayVertex(j);
				ver[j].wasVisited = true;
			}else{
				stack.pop();
			}
		}
		
		for(int i = 0 ; i < size ; i++){
			ver[i].wasVisited = false;
		}
		
		System.out.println("结束");
	}
	
	//该方法用于寻找某个顶点周围可用的顶点号
	private int findNext(int x){
		
		//如果该顶点邻接链表的第一个结点为空，也就是说周围没有其他节点了
		//此时查找失败直接返回-1
		if(ver[x].firstEdge == null){
			return -1;
		}
		
		//如果该顶点邻接链表第一个结点不为空且该顶点没有访问过
		if(ver[ver[x].firstEdge.id].wasVisited == false){
			//返回该顶点号
			return ver[x].firstEdge.id;
		}
		
		//将邻接链表第一个顶点的下一个顶点记为node
		ListVex node = ver[x].firstEdge.next;
		//如果该点不为空就检查是否被方为过，是就返回结点号
		//不是就推进指针，继续查找
		while(node != null){
			if(ver[node.id].wasVisited == false){
				return node.id;
			}else{
				node = node.next;
			}
		}
		
		//循环后如果还没有运行任何return语句那么最后返回-1，查找失败
		return -1;
	}
	
	//bfs遍历图，步骤与邻接矩阵实现图的方法一致
	//唯一不同之处在于将顶点周围所有可用顶点全加入队列的方法构造不同
	public void bfs(){
		queue = new LinkedList<Integer>();
		queue.offer(0);
		ver[0].wasVisited = true;
		while(!queue.isEmpty()){
			//该方法不同
			allInQueue(queue , queue.peek());
			int j = queue.poll();
			displayVertex(j);
		}
		
		for(int i = 0 ; i < size ; i++){
			ver[i].wasVisited = false;
		}
		
		System.out.println("结束");
	}
	
	//该方法用于将某个顶点周围所有可用顶点全加入队列中
	private void allInQueue(Queue<Integer> queue , int x){
		//如果该顶点第一个邻接结点为空，也就是该顶点周围没有顶点
		//此时直接返回
		if(ver[x].firstEdge == null){
			return;
		}
		
		//如果该顶点的第一个邻接结点不为空，且还没有被访问过，就将其加入队列
		//同时更新该顶点的标记，因为加入队列的顶点早晚会访问到
		if(ver[ver[x].firstEdge.id].wasVisited == false){
			queue.offer(ver[x].firstEdge.id);
			ver[ver[x].firstEdge.id].wasVisited = true;
		}
		
		//将第二个邻接结点称为node
		ListVex node = ver[x].firstEdge.next;
		//node只要不为空，就检查他是否被访问过，如果访问过那么就加入队列并更新标志
		//最后还要推进指针继续循环，无论是否有元素加入都要推进指针
		//因为所有的周围顶点都要检查而不是仅加入一个即可
		while(node != null){
			if(ver[node.id].wasVisited == false){
				queue.offer(node.id);
				ver[node.id].wasVisited = true;
			}
			node = node.next;
		}
	}
	
	//拓扑排序，排序的结果3-->1-->2-->6-->0-->4-->5-->12-->9-->10-->13-->11-->8-->7-->结束
	//它代表了执行了任务的先后次序，它不是唯一的
	//拓扑排序的原理在于寻找入度为0的顶点并将顶点的终点入度更新
	//这样不断寻找入度为0的顶点并打印
	public void aov(){
		//新建一个栈用来存放入度为0的点
		stack = new Stack<Integer>();
		//count用来统计拓扑排序完成个数
		int count = 0;
		
		//为了不使排序破坏每个顶点的域，创建一个数组统计每个点的入度
		int[] inDegreeArray = new int[size];
		//将各顶点的入度装入数组，其中有入度为0的压入栈中
		for(int i = 0 ;i < size ; i++){
			inDegreeArray[i] = ver[i].inDegree;
			if(inDegreeArray[i] == 0){
				stack.push(ver[i].id);
			}
		}
		
		//循环结束的标志是栈为空，此时没有入度为0的顶点也就不能在进行下去了
		while(!stack.empty()){
			//弹栈并将该值打印，排序的计数加1
			int j = stack.pop();
			System.out.print(j+"-->");
			count++;
			//接下来要更新该值对应的顶点的各终点的入度
			if(ver[j].firstEdge == null){
				//如果该顶点没有下一个终点就直接结束循环，此时没有要更新的入度
				continue;
			}else{
				//更新链表第一结点的入度，若入度为0压入栈中
				inDegreeArray[ver[j].firstEdge.id]--;
				if(inDegreeArray[ver[j].firstEdge.id] == 0){
					stack.push(ver[j].firstEdge.id);
				}
			}
			//将指针向后移，不断更新各终点的入度，若入度为0加入栈中
			ListVex edge = ver[j].firstEdge.next;
			while(edge != null){
				inDegreeArray[edge.id]--;
				if(inDegreeArray[edge.id] == 0){
					stack.push(edge.id);
				}
				edge = edge.next;
			}
		}
		//排序结果输出后检查count的值，如果不是全部顶点都输出过说明图存在环不是AOV图
		//如果全部顶点都输出了说明顺利完成了拓扑排序
		System.out.println("结束");
		if(count != size){
			System.out.println("异常");
		}else{
			System.out.println("拓扑排序正常完成");
		}
	}
}
~~~

## 关键路径

拓扑排序主要是为了解决一个工程能否顺序进行的问题，但有时我们还需要解决工程完成需要的最短时间问题。

在一个表示工程的带权有向图中，用顶点代表事件，用有向边表示活动，用边上的权值表示活动的持续时间，这种有向图的边表示活动的网，我们称之为AOE网（Activity On Edge Network），AOE网中没有入边的顶点称之为始点或源点，没有出边的顶点称为终点或汇点。

![QQ图片20230108131904](QQ图片20230108131904.png)

AOE网是表示工程流程的，在某顶点所代表的事件发生后，从该顶点出发的各活动才能开始；只有在进入某顶点的各活动都已经结束，该顶点所代表的事件才能发生。

AOE网和AOV网的区别：

* AOV网是顶点表示活动的网，它只描述活动之间的制约关系
* AOE网是用边表示活动的网，边上的权值表示活动持续的时间

![QQ图片20230108132356](QQ图片20230108132356.png)

各活动所持续的时间之和称为路径长度，从源点到汇点具有最大长度的路径叫关键路径，在关键路径上的活动称为关键活动。

如果我们需要缩短整个工期，必须缩短关键路径上的关键活动时间才可以减少工期，降低非关键路径上的活动时间是没有用的（但是可以通过减低活动时间让它变成关键路径）

### 核心思想

找出关键路径的核心思想：活动的最早开始时间等于它的最晚开始时间，此时就说明该活动是关键活动，它组成的路径是关键路径。

以下面的AOE网举例说明：

![QQ图片20230108132905](QQ图片20230108132905.png)

第一步：求出到达各个状态的最早时间（按最大计）

这个过程是要从源点开始向汇点顺推：

* V1是源点，其最早开始时间是0。
* V2、V3、V4最早时间分别是是6、4、5。
* 对于V5而言，V2到V5所花费时间是6+1=7，而V3到V5所花费时间是4+1=5。我们要按最大计，也就是V5最早时间是max{7,5}=7，按最大计是因为只有活动a4和a5同时完成了，才能到达V5状态。V3到V5需要5分钟，但是此时a4活动尚未完成（7分钟），所以都不能算到达V5，故而要按最大计。
* V6只有从V4到达，所以V6的最早完成时间是（5+2=）7。
* 同理，V7最早完成时间是16。
* 对于V8而言，和V5处理方法一致。V8=max{V5+7,V6+4}={7+7,7+4}=14。
* V9可算出是18。

这样，我们可以得到各个状态的最早时间的表：

![QQ图片20230108133038](QQ图片20230108133038.png)

第二步：求出到达各个状态的最晚时间（按最小计）

这个过程是要从汇点开始向源点逆推：

* V9完成时间为18，最V7最迟开始时间是（18-2=）16

  因为活动a10所需时间2。如果V7开始时间比16晚，则V9完成时间就会比18晚，这显然不对。

* 同理，V8最迟开始时间为14。
  对于V5而言，可以从V7、V8两个点开始向前推算，此时要按最小计，即V5(最晚)=min{V7-9,V8-7}=min{16-9,14-7}=7。
  请注意！！，min{V7-9,V8-7}中，V7、V8取的都是前面算出的最迟开始时间（而不是最早开始时间）。

* 同理，可计算出剩下的点

这样，我们可以得到各个状态的最晚时间的表：

![QQ图片20230108133607](QQ图片20230108133607.png)

源点和汇点的最晚时间和最早时间必定是相同的。

第三步：求出关键路径

对于a1：

![QQ图片20230108133706](QQ图片20230108133706.png)

这表明，a1最早只能从0时刻开始，最晚也只能从（6-6=）0时刻开始，因此，a1是关键活动。

对于a2：

![QQ图片20230108133734](QQ图片20230108133734.png)

a2最早要从0时刻开始，但是它最晚开始时间却是（6-4=）2。也就是说，从0开始做，4时刻即完成；从2开始做，6时刻恰好完成。从而在[0,2]区间内任意时间开始做a2都能保证按时完成。

（请区别顶点的最早最晚和活动的最早最晚时间。图示中的最早最晚是顶点状态的时间）

由于a2的开始时间是不定的，所以它不能主导工程的进度，从而它不是关键活动。

一般的：

![QQ图片20230108133834](QQ图片20230108133834.png)

活动用时X时间，它最早要从E1时刻开始（一开始就开始），最晚要从L2-X时刻开始（即恰好完成）。所以，如果它是关键活动，则必然有E1=L2-X，否则它就不是关键活动。

综上：蓝色底纹表示的点即为处于关键路径的点

![QQ图片20230108134013](QQ图片20230108134013.png)

最终的关键路径：

![QQ图片20230108134057](QQ图片20230108134057.png)

对一个具有n个顶点e条弧的AOE网来说，算法时间复杂度是O(n+e)

有时关键路径是多条，此时必须同时提高多条关键路径上活动的速度，才能缩短整个工期。

### 代码实现

下面是一个基于邻接表实现的有向加权图，其中求关键路径的方法是criticalPath

~~~java
//与AOV不同之处在于邻接结点都添加了一个权值的域
class AOE_ListGraph{
	
	//顶点数组
	private Vertex[] ver;
	//顶点数组的默认大小
	private static final int DEFAULT_SIZE = 20;
	//size表示图中的顶点数
	private int size;
	//dfs中用的栈
	private Stack<Integer> stack;
	//bfs中用的队列
	private Queue<Integer> queue;
	//用来存放拓扑序列的栈，在查找关键路径时用到
	private Stack<Integer> stack_reverse;
	//etv表示事件（顶点）的最早开始时间
	private int[] etv;
	//ltv表示事件（顶点）的最晚开始时间
	private int[] ltv;
	
 	
	//顶点类
	private static class Vertex{
		//分别代表号、顶点名、顶点标记、第一个邻接结点
		int id;
		String name;
		boolean wasVisited;
		ListVex firstEdge;
		//顶点的入度
		int inDegree;
				
		//有参构造，默认结点未被访问
		public Vertex(String name){
			this.name = name;
			wasVisited = false;
			inDegree = 0;
		}
	}
	
	//邻接链表结点类
	private static class ListVex{
		//结点号和下一个结点指针、边的权值
		int id;
		ListVex next;
		int weight;
		//有参构造，默认下个结点为空
		public ListVex(int id , int weight){
			this.id = id;
			this.weight = weight;
			next = null;
		}
	}
	
	//图的初始化，分配一个默认大小的顶点数组
	public AOE_ListGraph(){
		ver = new Vertex[DEFAULT_SIZE];
		//将顶点个数初始化为0 
		size = 0;
	}
	
	//添加顶点方法
	public void addVertex(String name){
		//将顶点数组的下一个值赋值为新建顶点
		ver[size] = new Vertex(name);
		//此时的size值就赋值为顶点id
		ver[size].id = size;
		//默认新建顶点的第一个邻接结点为空
		ver[size].firstEdge = null;
		//最后顶点数加1
		size++;
	}
	
	//添加边方法，需提供起始id和终止id
	public void addEdge(int begin , int end , int weight){
		
		//创建两个结点类为下方操作做准备
		ListVex node;
		ListVex secondNode;
		
		//若输入的起始和终止相同就抛出一个异常
		if(begin == end){
			throw new IllegalStateException();
		}
		
		//第一部分：将起始id对应的邻接链表更新：添加一个包含end信息的结点
		//第一个邻接结点要单独处理，因为firstEdge不能连续向下推进
		//如果第一个邻接结点为空，那么就新建一个邻接结点并将其作为第一结点
		if(ver[begin].firstEdge == null){
			ver[begin].firstEdge = new ListVex(end , weight);
		}else{
			//如果第一个邻接结点不为空，那么就向下推进结点
			//将第一个邻接结点给node，然后令node作为新的邻接结点
			//这样node就成了新的第一结点
			node = ver[begin].firstEdge;
			ver[begin].firstEdge = node;
			//只要node下还有其他节点，就将node赋值为下一个结点
			while(node.next != null){
				node = node.next;
			}
			//直至node没有下一个结点，此时将下一个结点设置为新建的包含end信息的结点
			node.next = new ListVex(end , weight);
			
		}
		
		//终止顶点的入度加1
		ver[end].inDegree++;
		
	}
		
	//打印某个结点的name
	public void displayVertex(int id){
		System.out.print(ver[id].name + "-->");
	}
	
	//计算度的方法
	public int degree(int id){
		//初始化度为0
		int count = 0;
		//将code记为第id个结点的第一个邻接结点
		ListVex code = ver[id].firstEdge;
		//只要第一结点不为空就把count加一，并继续向后推进
		while(code != null){
			count++;
			code = code.next;
		}
		//循环结束后此时的count值就是度
		return count;
	}
	
	//dfs遍历图，与邻接矩阵实现的dfs遍历相同
	//不同之处仅在于寻找顶点周围下一个可用的顶点方法构造不同
	public void dfs(){
		stack = new Stack<Integer>();
		stack.push(0);
		displayVertex(0);
		ver[0].wasVisited = true;
		while(!stack.empty()){
			//这个方法构造不同
			int j = findNext(stack.peek());
			if(j != -1){
				stack.push(j);
				displayVertex(j);
				ver[j].wasVisited = true;
			}else{
				stack.pop();
			}
		}
		
		for(int i = 0 ; i < size ; i++){
			ver[i].wasVisited = false;
		}
		
		System.out.println("结束");
	}
	
	//该方法用于寻找某个顶点周围可用的顶点号
	private int findNext(int x){
		
		//如果该顶点邻接链表的第一个结点为空，也就是说周围没有其他节点了
		//此时查找失败直接返回-1
		if(ver[x].firstEdge == null){
			return -1;
		}
		
		//如果该顶点邻接链表第一个结点不为空且该顶点没有访问过
		if(ver[ver[x].firstEdge.id].wasVisited == false){
			//返回该顶点号
			return ver[x].firstEdge.id;
		}
		
		//将邻接链表第一个顶点的下一个顶点记为node
		ListVex node = ver[x].firstEdge.next;
		//如果该点不为空就检查是否被方为过，是就返回结点号
		//不是就推进指针，继续查找
		while(node != null){
			if(ver[node.id].wasVisited == false){
				return node.id;
			}else{
				node = node.next;
			}
		}
		
		//循环后如果还没有运行任何return语句那么最后返回-1，查找失败
		return -1;
	}
	
	//bfs遍历图，步骤与邻接矩阵实现图的方法一致
	//唯一不同之处在于将顶点周围所有可用顶点全加入队列的方法构造不同
	public void bfs(){
		queue = new LinkedList<Integer>();
		queue.offer(0);
		ver[0].wasVisited = true;
		while(!queue.isEmpty()){
			//该方法不同
			allInQueue(queue , queue.peek());
			int j = queue.poll();
			displayVertex(j);
		}
		
		for(int i = 0 ; i < size ; i++){
			ver[i].wasVisited = false;
		}
		
		System.out.println("结束");
	}
	
	//该方法用于将某个顶点周围所有可用顶点全加入队列中
	private void allInQueue(Queue<Integer> queue , int x){
		//如果该顶点第一个邻接结点为空，也就是该顶点周围没有顶点
		//此时直接返回
		if(ver[x].firstEdge == null){
			return;
		}
		
		//如果该顶点的第一个邻接结点不为空，且还没有被访问过，就将其加入队列
		//同时更新该顶点的标记，因为加入队列的顶点早晚会访问到
		if(ver[ver[x].firstEdge.id].wasVisited == false){
			queue.offer(ver[x].firstEdge.id);
			ver[ver[x].firstEdge.id].wasVisited = true;
		}
		
		//将第二个邻接结点称为node
		ListVex node = ver[x].firstEdge.next;
		//node只要不为空，就检查他是否被访问过，如果访问过那么就加入队列并更新标志
		//最后还要推进指针继续循环，无论是否有元素加入都要推进指针
		//因为所有的周围顶点都要检查而不是仅加入一个即可
		while(node != null){
			if(ver[node.id].wasVisited == false){
				queue.offer(node.id);
				ver[node.id].wasVisited = true;
			}
			node = node.next;
		}
	}
	
	//拓扑排序，排序的结果3-->1-->2-->6-->0-->4-->5-->12-->9-->10-->13-->11-->8-->7-->结束
	//它代表了执行了任务的先后次序，它不是唯一的
	//拓扑排序的原理在于寻找入度为0的顶点并将顶点的终点入度更新
	//这样不断寻找入度为0的顶点并打印
	
	//与原有的拓扑排序增加了一个存放拓扑排序的栈，在后面计算最晚开始时间时要逆序进行
	//在完成拓扑排序功能的同时计算各顶点的最早开始时间，它的进行是拓扑排序的逆序
	public void aov(){
		//新建一个栈用来存放入度为0的点
		stack = new Stack<Integer>();
		//stack_reverse是用来存拓扑排序顺序的栈
		stack_reverse = new Stack<Integer>();
		//etv是表示各顶点最早开始时间的数组，数组大小与顶点数一致
		etv = new int[size];
		//count用来统计拓扑排序完成个数
		int count = 0;
		
		//为了不使排序破坏每个顶点的域，创建一个数组统计每个点的入度
		int[] inDegreeArray = new int[size];
		//将各顶点的入度装入数组，其中有入度为0的压入栈中
		for(int i = 0 ;i < size ; i++){
			inDegreeArray[i] = ver[i].inDegree;
			if(inDegreeArray[i] == 0){
				stack.push(ver[i].id);
			}
		}
		
		//循环结束的标志是栈为空，此时没有入度为0的顶点也就不能在进行下去了
		while(!stack.empty()){
			//弹栈并将该值打印，排序的计数加1
			int j = stack.pop();
			System.out.print(j+"-->");
			count++;
			//打印完顶点后把值压入stack_reverse栈中
			stack_reverse.push(j);
			
			//接下来要更新该值对应的顶点的各终点的入度
			if(ver[j].firstEdge == null){
				//如果该顶点没有下一个终点就直接结束循环，此时没有要更新的入度
				continue;
			}else{
				//更新链表第一结点的入度，若入度为0压入栈中
				inDegreeArray[ver[j].firstEdge.id]--;
				if(inDegreeArray[ver[j].firstEdge.id] == 0){
					stack.push(ver[j].firstEdge.id);
				}
				//如果原来第一结点的最早开始时间小于j的最早开始时间加j到第一结点的时间就将其替换
				if(etv[ver[j].firstEdge.id] < etv[ver[j].id] + ver[j].firstEdge.weight){
					etv[ver[j].firstEdge.id] = etv[ver[j].id] + ver[j].firstEdge.weight;
				}
			}
			//将指针向后移，不断更新各终点的入度，若入度为0加入栈中
			ListVex edge = ver[j].firstEdge.next;
			while(edge != null){
				inDegreeArray[edge.id]--;
				if(inDegreeArray[edge.id] == 0){
					stack.push(edge.id);
				}
				//如果该节点的最早开始时间小于j的最早开始时间加j到该节点的时间就将其替换
				//这样每个边都操作完成后，剩下的最早开始时间的最大值就是最终的最早开始时间
				//因为该点要想最早开始必须所有前驱结点都完成才行
				if(etv[edge.id] < etv[ver[j].id] + edge.weight){
					etv[edge.id] = etv[ver[j].id] + edge.weight;
				}
				edge = edge.next;
			}
		}
		//排序结果输出后检查count的值，如果不是全部顶点都输出过说明图存在环不是AOV图
		//如果全部顶点都输出了说明顺利完成了拓扑排序
		System.out.println("结束");
		if(count != size){
			System.out.println("异常");
		}else{
			System.out.println("拓扑排序正常完成");
		}
		//打印etv，即各顶点的最早开始时间
		System.out.println(Arrays.toString(etv));
		
	}
	
	//求关键路径，一条边的最早开始时间和最晚开始时间相同的边即为关键边
	//关键边连成路径即为关键路径
	//通过求etv（各顶点的最早开始时间）和ltv（各顶点的最晚开始时间）
	//求ete（各边的最早开始时间）和lte（各边的最晚开始时间）再对比其是否相等
	public void criticalPath(){
		
		//ltv（各顶点的最晚开始时间）大小为顶点个数
		ltv = new int[size];
		//stack_reverse栈顶即为拓扑序列的终点，也是查找ltv算法的起点
		//因为终点一定在关键路径上，它本身的最晚开始时间就等于最早开始时间
		//初始化ltv时把所有最晚时间都设置为与最后一个位置相同，算法进行中会逐步修正它的值
		int k = stack_reverse.peek();
		for(int i = 0 ; i < size ; i++){
			ltv[i] = etv[k];
 		}
		//当stack_reverse为空时就意味着没有要处理的顶点，循环结束
		while(!stack_reverse.empty()){
			//将栈顶弹出
			int j = stack_reverse.pop();
			//判断该元素是否有第一结点，没有直接结束循环
			if(ver[j].firstEdge == null){
				continue;
			}else{
				//如果有第一结点，考虑是否修正栈顶元素的ltv
				//如果本节点的最晚开始时间大于本节点的第一结点的最晚时间与边上权的差就更新它的值
				if(ltv[ver[j].id] > ltv[ver[j].firstEdge.id] - ver[j].firstEdge.weight){
					ltv[ver[j].id] = ltv[ver[j].firstEdge.id] - ver[j].firstEdge.weight;
				}
			}
			//继续向链表深处探索
			ListVex edge = ver[j].firstEdge.next;
			while(edge != null){
				//如果本节点的最晚时间大于本节点的后驱结点的最晚开始时间减去边上权值就更新它的值
				//这样最后所有边都操作一遍后，剩下的应该是最晚时间中的最小值，它就是顶点最终的最晚开始时间
				if(ltv[ver[j].id] > ltv[edge.id] - edge.weight){
					ltv[ver[j].id] = ltv[edge.id] - edge.weight;
				}
				edge = edge.next;
			}
		}
		//输出ltv（各顶点的最晚开始时间）
		System.out.println(Arrays.toString(ltv));
		
		//定义ete（各边的最早开始时间）、lte（各边的最晚开始时间）
		int ete = 0 , lte = 0;
		//开始循环每条边
		for(int i = 0 ; i < size ; i++){
			//首先是第一结点，为空直接开始下一次循环
			if(ver[i].firstEdge == null){
				continue;
			}else{
				//各边的最早开始时间就相当于弧头顶点的最早开始时间
				ete = etv[i];
				//各边的最晚开始时间就相当于弧尾顶点的最晚开始时间减去边上的时间
				lte = ltv[ver[i].firstEdge.id] - ver[i].firstEdge.weight;
				//如果两者相等那么这条弧就是关键路径，打印出来
				if(ete == lte){
					System.out.print(ver[i].id+"-->"+ver[i].firstEdge.id+" ");
				}
			}
			//继续向链表深处推进
			ListVex edge = ver[i].firstEdge.next;
			while(edge != null){
				//各边的最早开始时间就相当于弧头顶点的最早开始时间
				ete = etv[i];
				//各边的最晚开始时间就相当于弧尾顶点的最晚开始时间减去边上的时间
				lte = ltv[edge.id] - edge.weight;
				//如果两者相等那么这条弧就是关键路径，打印出来
				if(ete == lte){
					System.out.print(ver[i].id+"-->"+edge.id+" ");
				}
				edge = edge.next;
			}
		}
	}
}
~~~

# 查找

查找表按照操作方式分为两大种：静态查找表和动态查找表：

* 静态查找表只是查找某个特定元素是否在查找表中，或者检索某个属性
* 动态查找表可以在查找时插入或者删除元素

查找所基于的数据结构是集合，集合中的记录之间没有本质关系，但是为了获得比较高的查找性能，有时不得不改变数据元素之间的关系，将查找集合组织成表、树等结构

对于静态查找表来说，可以采用线性表来组织数据，使用顺序查找算法，如果对主关键字进行排序还可以使用二分法等方法查找

对于动态查找表来说，因为考虑到更新效率，考虑使用二叉排序树等。

## 顺序查找

顺序查找（Sequential Search）又叫线性查找，是最基本的查找技术，它的查找过程就是简单遍历集合。

它的时间复杂度是On，它算法逻辑简单，n很大时查找效率低下。因为查找概率的不同，可以将容易查找到的记录放在前面，把不常用的记录放置在后面，效率就可以有所提高。

## 有序表查找

### 二分查找

Binary Search，它的时间复杂度是Ologn，每次mid=(low+high)/2

~~~java
public static int Binary_Search(int[] a , int b){
  int low = 0;
  int high = a.length - 1;

  while(low <= high){
    int mid = (low + high)/2;
    if(a[mid] < b){
      low = mid + 1;
    }else if(a[mid] > b){
      high = mid - 1;
    }else{
      return mid;
    }
  }

  return -1;
}
~~~

### 插值查找

有时查找时不一定要每次折半，就如同在字典中查找apple的时候，绝对不会从中间开始查找，而是从书的开头开始查找。

对于取值范围0-10000之间100个元素均匀分布的数组中查找5，就会考虑从数组下标较小的开始查找。

在二分查找中，每次mid的取值：mid=(low+high)/2=low+1/2 * (high - low)

插值查找不同的地方就在于将这个1/2进行改进，改为下面的计算方案：
$$
mid = low + (key - a[low]) / (a[high] - a[low]) * (high - low)
$$
这就是插值查找（Interpolation Search），它的时间复杂度也是Ologn，对于分布比较均匀，表比较长的查找表来说，插值查找算法的平均性能要优于二分查找，但是对于极端不均匀的数据，还是二分查找更合适

~~~java
public static int Interpolation_Search(int[] a , int b){
  int low = 0;
  int high = a.length - 1;

  while(low <= high){
    int mid = low + (b - a[low])*(high - low)/(a[high] - a[low]);
    if(a[mid] < b){
      low = mid + 1;
    }else if(a[mid] > b){
      high = mid - 1;
    }else{
      return mid;
    }
  }

  return -1;
}
~~~

### 斐波那契查找

斐波那契查找（Fibonacci Search）是利用了黄金分割原理实现的。

斐波那契数列：F(0)=1，F(1)=1, F(n)=F(n - 1)+F(n - 2)（n ≥ 2，n ∈ N*），随着数列项数的增加，前一项与后一项之比越来越逼近黄金分割的数值

斐波那契查找实际上是把mid=(low+high)/2=low+1/2 * (high - low)中的1/2替换为了黄金分隔数。

它的时间复杂度也是Ologn，但就平均性能来说，它要优于二分查找。

## 线性索引查找

索引就是把一个关键字与它对应的记录相关联的过程。

索引按照结构可以分为线性索引、树形索引和多级索引。这里只介绍线性索引，所谓线性索引就是将索引项集合组织成为线性结构，也称为索引表。

这里重点介绍三种索引：稠密索引、分块索引和倒排索引

### 稠密索引

稠密索引是指在线性索引中，将数据集中的每个记录对应一个索引项，如下图所示：

![QQ图片20230108184347](QQ图片20230108184347.png)

数据项可以是乱序排放的，但是索引项一定是有序的，这样就可以先用有序查找算法找到索引项，然后再根据索引项找到数据记录。

当数据集非常大的时候，索引的规模和就和数据差不多了，如果索引项保存在磁盘中，此时就要反复访问磁盘，性能不好。

### 分块索引

为了减少索引项的个数，可以对数据集进行分块，使其分块有序，然后再对每一个块建立一个索引项。

基本的原则是：块内无序、块间有序

每个索引项包含三种信息：块内最大关键码、块记录数、指向块首数据的指针

![QQ图片20230108185055](QQ图片20230108185055.png)

在分块索引表中查找记录，首先要找到块对应的索引，这一步可以使用有序查找加快速度；然后在块中顺序查找。

假设n个记录的数据集被平均分为m块，每个块中有t条记录，此时n=m*t。顺序查找索引表的平均查找长度是(m+1)/2，块中查找记录的平均查找长度是(t+1)/2，这样一次分块查找的平均查找长度是两者相加，等于(n/t+t)/2+1，当m=t时，该值最小，为根号n+1，比On更好，但是比Ologn更差。

### 倒排索引

倒排索引用于搜索引擎，将一个完整的句子进行分词后存入索引表中，每个索引项包含单词（次关键码）和文章编号两个信息：

![QQ图片20230108195625](QQ图片20230108195625.png)

这种索引不是由记录来确定属性值，而是用属性值来确定记录的位置，因此被称为倒排索引（inverted index）

## 二叉排序树

查找时插入或删除的查找表被称为动态查找表，如果要保持集合的顺序同时进行插入，如果用线性表来实现，插入时还需要移动其他元素，而如果用树来实现，插入时则不需要移动其他元素：

![QQ图片20230108203545](QQ图片20230108203545.png)

这样的二叉树就是二叉排序树（Binary Sort Tree），对它进行中序遍历时可以得到一个有序的序列，它的定义：

它或者是一棵空树，或者是具有如下性质的二叉树：

* 若它的左子树不空，则左子树上所有结点的值均小于它的根结构的值
* 若它的右子树不空，则右子树上所有结点的值均大于它的根结构的值
* 它的左、右子树也是二叉排序树

它最大的特点就是实现查找的同时，可以快速插入和删除元素。

比较复杂的是二叉排序树的删除，如果要删除的结点是叶子结点，则比较简单，直接删除即可，不会对树的结构由影响：

![QQ图片20230108204130](QQ图片20230108204130.png)

如果要删除的结点只有左子树或者只有右子树，那也比较简单，只需要将它的左子树或者右子树（如果算法中一直指定左子树，或者一直指定右子树，长时间插入删除可能会造成树的不平衡）移动到删除结点的位置即可：

![QQ图片20230108204225](QQ图片20230108204225.png)

对于要删除的结点既有左子树又有右子树的情况，此时应该找到要删除结点的直接前驱或者直接后驱结点，然后将它移动到要删除结点的位置：

![QQ图片20230108204418](QQ图片20230108204418.png)

如果删除的次数不多，可以使用懒惰删除，当一个元素要被删除时，它扔留在树中，只是被标记为删除。当树中的实际节点数和被删除的节点数相同，树的深度只会上升一个比较小的常数。而且懒惰删除对于那种刚刚删除又重新插入的场景非常有效，可以避免新单元的分配开销。

二叉排序树的插入、删除、查找的平均时间复杂度都是Ologn，但是有时因为插入的元素都是有序的，结果会导致二叉排序树变成斜树，此时查找的时间复杂度会退化到On，所以保持二叉树的平衡就是保证他的查找性能。

下面是一个普通二叉查找树的例子，实现了makeEmpty、isEmpty、contains、findMax、findMin、insert、remove、printTree方法：

~~~java
class BinarySearchTree<AnyType extends Comparable<? super AnyType>> {
	
	//唯一的域变量，根节点本身，每次对二叉树进行修改操作实际上都在修改根节点
	BinaryNode<AnyType> root;
	//一个嵌套类，描述节点构造
	

	//二叉树的无参构造，就是给根节点赋null
	public BinarySearchTree() {
		super();
		root = null;
	}
	
	//二叉树的清空
	public void makeEmpty(){
		root = null;
	}
	
	//判断二叉树是否为空
	public boolean isEmpty(){
		return root == null;
	}
	
	//判断二叉树是否包括该元素，因为递归的原因又将它传入一个新的方法中
	public boolean contains(AnyType element){
		return contains(root,element);
	}

	//判断二叉树是否包含该元素
	private boolean contains(BinaryNode<AnyType> x, AnyType element) {
		
		//如果树是null，那么就返回null，查找结束没有元素
		if(x == null){
			return false;
		}
		
		//如果元素比该节点元素大，那么去右子树寻找，否则去左子树
		//直至树为空或两结点相等，返回true
		//这里使用的compareto方法都是因为AnyType实现了Comparable的结果
		if(element.compareTo(x.element) > 0){
			return contains(x.right,element);
		}else if(element.compareTo(x.element) < 0){
			return contains(x.left,element);
		}else{
			return true;
		}
	}
	
	//查找二叉树的最大值
	public AnyType findMax(){
		
		//如果根节点为null，那么就抛出一个异常，无法查找最大值
		if(root == null){
			throw new RuntimeException();
		}
		//将根节点的索引赋给另一个变量，以免之后修改根节点索引
		BinaryNode<AnyType> t = root;
		
		//只要改结点还有右结点就继续向右查找
		while(t.right != null){
			t = t.right; 
		}
		//直至没有右结点了，此时数据即为最大值
		return t.element;
	}
	
	//查找二叉树的最小值，因为后面要实现一个在子树中查找最值的方法
	//故实现那个新的方法并把功能传递过去
	public AnyType findMin(){
		
		if(root == null){
			throw new RuntimeException();
		}
		return findMin(root).element;
	}
	
	private BinaryNode<AnyType> findMin(BinaryNode<AnyType> t){
		while(t.left != null){
			t = t.left; 
		}
		return t;
	}
	
	//插入也需要递归，故重新建立一个函数
	//插入实质上就是更新根节点，故要把新的根节点赋给原根节点
	public void insert(AnyType element){
		root = insert(root,element);
	}

	//插入操作
	private BinaryNode<AnyType> insert(BinaryNode<AnyType> x, AnyType element) {
		
		//如果树为空，那么就返回一个以该元素为数据域的新节点
		//也就是插入新节点
		if(x == null){
			return new BinaryNode<AnyType>(element);
		}
		
		//如果树的数据域比元素的小，那么说明该元素在右子树内
		//也就是说如果该元素存在的话，更新一定发生在右子树内
		//故将右子树的索引更新
		//否则更新左子树的索引
		if(element.compareTo(x.element) > 0){
			x.right = insert(x.right,element);
		}else if(element.compareTo(x.element) < 0){
			x.left = insert(x.left,element);
		}else{
			//若树的数据域与要插入的值相等，那么什么都不做
			;
		}
		//如果递归没有因为子树等于null，也就是插入新节点结束
		//那么就把索引返回，相当于什么都没有做
		return x;
	}
	
	//将二叉树的数据删除
	//因为需要递归操作，故新建了一个同名方法
	public void remove(AnyType element){
		root = remove(root,element);
	}

	private BinaryNode<AnyType> remove(BinaryNode<AnyType> x, AnyType element) {
		
		//如果树节点为空，那么就返回空
		//适用于传入root，且root为空的情况
		//还适用于递归中没有找到该元素的情况
		if(x == null){
			return null;
		}
		
		//将比较的值记录一下，以免多次计算
		int compareTo = element.compareTo(x.element);
		
		//如果树节点的数据域比元素小，那么就更新右子树的索引
		//否则更新左子树
		if(compareTo > 0){
			x.right = remove(x.right , element);
		}else if(compareTo < 0){
			x.left = remove(x.left , element);
			
			//直至找到了要删除的元素，当该节点此时既有左孩子又有右孩子时
			//选取右子树的最小值作为该节点的值，当然也可以选择左子树的最大值更新节点值
			//将值更新后，把对应子树的该元素删除，再次调用递归
		}else if(x.left != null && x.right != null){
			x.element = findMin(x.right).element;
			x.right = remove(x.right , x.element);
		}else{
			//找到了要删除的元素，但是他只有左孩子或只有右孩子
			//如果有左孩子就把连接给左孩子，否则就给右孩子
			//这样的处理也可以应用于叶子节点上，因为此时什么都没有，一定会被赋值为null
			x = (x.right == null ? x.left:x.right);
		}
		return x;
	}
	
	public void printTree(){
		
		if(root == null){
			System.out.println("empty tree");
		}else{
			printTree(root);
		}
	}
	
	//中序遍历树并打印
	private void printTree(BinaryNode<AnyType> x){
		
		//因为每一个结点都要访问它的左右子树
		//势必出现叶子节点或其他节点没有左或右子树的情形
		//此时什么都不做，直接完成方法的调用
		//继续递归
		if(x != null){
			printTree(x.left);
			System.out.print(x.element+" ");
			printTree(x.right);
		}
	}
}
~~~

## 平衡二叉树

平衡二叉树是一种二叉排序树，其中每一个节点的左子树和右子树的高度差至多等于1.

AVL树是一种典型的平衡二叉树。

二叉树上节点的左子树深度减去右子树深度的值称为平衡因子BF（Balance Factor），平衡二叉树上所有结点的平衡因子只可能是-1、0和1.

距离插入结点最近的，且平衡因子的绝对值大于1的结点为根的子树，称为最小不平衡子树。平衡二叉树构建的基本思想就是在构建树的过程中，每当插入一个结点时，先检查是否因插入破坏了树的平衡性，若是找出最小不平衡子树，然后调整它的结构，进行响应的旋转，使之成为新的平衡子树。

![QQ图片20230108205202](QQ图片20230108205202.png)



不平衡的情况有四种可能：（重新平衡的节点记为A）

* 对A的左儿子的左子树进行一次插入
* 对A的左儿子的右子树进行一次插入
* 对A的右儿子的左子树进行一次插入
* 对A的右儿子的右子树进行一次插入

其中第一种情况和第四种情况是对称的，需要通过一次单旋转（single rotation）来完成调整。第二和第三是对称的，需要完成双旋转（double rotation）来调整。

单旋转示意图：

![QQ图片20230108223809](QQ图片20230108223809.png)

对于第二和第三种场景，单旋转是不够的，此时无法降低它的深度：

![QQ图片20230108224257](QQ图片20230108224257.png)

下面是双旋转的示意图：

![QQ图片20230108224334](QQ图片20230108224334.png)

在平衡的过程中，树的深度是一个很重要的值，为此专门为树结点增加一个代表深度的属性。

用一个专门的方法balance来平衡一棵树，方法是递归检查结点左子树和右子树的深度，判断是上面四种模式的哪一种，然后执行对应的旋转。插入和删除操作后执行balance方法就能调整树的结构实现平衡，这样就不用专门设计平衡二叉树的删除方式了。

下面是一个AVL树的代码例子，实现了makeEmpty、isEmpty、contains、findMax、findMin、insert、remove、printTree方法：

~~~java
class avlSearchTree<AnyType extends Comparable<? super AnyType>> {

	//唯一的域：根节点
	private avlNode<AnyType> root;

	//AVL树的节点构造，比普通二叉树多了一个高度值
	//高度是从本节点到端节点的路径段数
	private static class avlNode<AnyType> {

		avlNode<AnyType> left;
		avlNode<AnyType> right;
		AnyType element;
		int height;

		public avlNode(AnyType element, avlNode<AnyType> left,
				avlNode<AnyType> right) {
			super();
			this.left = left;
			this.right = right;
			this.element = element;
			// 新建立的节点一定是叶子节点，高度一定是0
			height = 0;
		}

		public avlNode(AnyType element) {
			this(element, null, null);
		}
	}

	public void makeEmpty() {
		root = null;
	}

	public boolean isEmpty() {
		return root == null;
	}

	public avlSearchTree() {
		super();
		root = null;
	}

	//contains方法与普通二叉树一致
	public boolean contains(AnyType element) {
		return contains(root, element);
	}

	private boolean contains(avlNode<AnyType> x, AnyType element) {

		if (x == null) {
			return false;
		}

		if (element.compareTo(x.element) > 0) {
			return contains(x.right, element);
		} else if (element.compareTo(x.element) < 0) {
			return contains(x.left, element);
		} else {
			return true;
		}
	}

	//findMax方法与普通二叉树一致
	public AnyType findMax() {
		return findMax(root).element;
	}

	private avlNode<AnyType> findMax(avlNode<AnyType> x) {

		if (x == null) {
			throw new RuntimeException();
		}

		avlNode<AnyType> t = x;
		while (t.right != null) {
			t = t.right;
		}
		return t;
	}

	//findMin方法与普通二叉树一致
	public AnyType findMin() {
		return findMin(root).element;
	}

	private avlNode<AnyType> findMin(avlNode<AnyType> x) {

		if (x == null) {
			throw new RuntimeException();
		}

		avlNode<AnyType> t = x;
		while (t.left != null) {
			t = t.left;
		}
		return t;
	}

	//放回节点的高度值
	//这里将null节点的高度值设置成-1
	private int height(avlNode<AnyType> x) {
		return x == null ? -1 : x.height;
	}

	//插入方法需要递归，故将其传入新购造的方法中
	public void insert(AnyType element) {
		// mid_height = 1;
		root = insert(root, element);
	}

	// private int mid_height = 1;

	//除了最后加上了平衡操作，其余所有操作都与普通二叉树一致
	private avlNode<AnyType> insert(avlNode<AnyType> x, AnyType element) {

		if (x == null) {
			// avlNode<AnyType> y = new avlNode<AnyType>(element);
			// y.height = mid_height;
			return new avlNode<AnyType>(element);
		}

		int compare = element.compareTo(x.element);

		if (compare > 0) {
			x.right = insert(x.right, element);
		} else if (compare < 0) {
			x.left = insert(x.left, element);
		} else {
			;
		}
		//对每个节点都进行平衡操作
		//这里返回的实际上是从插入节点到根节点的所有节点
		//这些节点都有可能产生不平衡
		//即使节点不平衡也要进行高度的更新，因为一旦插入一个新节点
		//这些节点的高度值都要更新一遍
		return balance(x);
	}

	private avlNode<AnyType> balance(avlNode<AnyType> x) {

		//平衡方法首先检查左右子树的高度值是否差大于1，若大于1就是不平衡
		//这里基于平衡操作的四种情形设计了四种分支
		//分别进行对应的单旋转和双旋转
		if ((height(x.left) - height(x.right)) > 1) {
			//这里有一个细节问题：这里的判断用的是大于等于号
			//实际上在进行插入操作时不可能发生相等的情况，因为插入后相等
			//就说明该子树的高度插入前后没有变化，也就不可能产生不平衡
			//只要出现了不平衡情况，就不可能出现等号的情况
			//这里之所以用了等号实际上是考虑到删除后也要进行平衡操作
			//删除一个结点后，因为另一个子树高度比该子树高度大了2
			//且另一个子树本身并没有限定，它完全有可能出现某个子树左右平衡的情况
			//此时依然需要单旋转进行解决，故用等号把上述所有的可能都归于下条语句
			if (height(x.left.left) >= height(x.left.right)) {
				//左-左插入后的结果用单旋转
				//对删除的情况也一样适用
				//因为无论是插入还是删除本质上都是对树结构的改变
				//这里将树传入对它进行结构上的改变，没必要弄清树为什么已经有了这样的结构
				x = rotateWithLeftChild(x);
			} else {
				//左-右插入后的结果用双旋转
				x = doubleRotateWithLeftChild(x);
			}
		} else if ((height(x.right) - height(x.left)) > 1) {
			if (height(x.right.right) >= height(x.right.left)) {
				x = rotateWithRightChild(x);
			} else {
				x = doubleRotateWithRightChild(x);
			}
		}

		//在对x结点，也就是传入子树的根节点，下的各结构进行更新外
		//还需要进行高度的更新
		//在旋转时也对x的高度进行了更新，这里再更新一次是为了让
		//所有的平衡结点也进行高度的更新
		x.height = Math.max(x.left.height, x.right.height) + 1;
		return x;
	}

	//绕左孩子进行单旋转
	private avlNode<AnyType> rotateWithLeftChild(avlNode<AnyType> x) {

		//将左孩子提为根节点，并重新调整结构
		avlNode<AnyType> t = x.left;
		x.left = t.right;
		t.right = x;
		//将修改的两个结点高度进行更新
		//子树的各节点高度不必更新，因为他们到端节点的部分没有改变
		x.height = Math.max(x.left.height, x.right.height);
		t.height = Math.max(x.height, t.left.height);

		return t;
	}

	//绕右孩子进行单旋转
	private avlNode<AnyType> rotateWithRightChild(avlNode<AnyType> x) {

		avlNode<AnyType> t = x.right;
		x.right = t.left;
		t.left = x;
		x.height = Math.max(x.left.height, x.right.height);
		t.height = Math.max(x.height, t.right.height);

		return t;
	}
	
	//绕左孩子进行双旋转
	private avlNode<AnyType> doubleRotateWithLeftChild(avlNode<AnyType> x){
		
		//先对左子树进行单旋转操作，将左子树的右孩子提为根节点
		x.left = rotateWithRightChild(x.left);
		//再对本树进行单旋转操作，将左孩子提为根节点
		//至此，原左子树的右孩子进行两次提拔到达了根节点的位置
		//双旋转完成
		return rotateWithLeftChild(x);
	}
	
	//绕右孩子进行双旋转
	private avlNode<AnyType> doubleRotateWithRightChild(avlNode<AnyType> x){
		
		x.right = rotateWithLeftChild(x.right);
		return rotateWithRightChild(x);
	}
	
	//删除操作除了最后需要平衡外与普通二叉树一样
	public void remove(AnyType element){
		root = remove(root , element);
	}
	
	private avlNode<AnyType> remove(avlNode<AnyType> x , AnyType element){
		
		if(x == null){
			return x;
		}
		
		int compare = element.compareTo(x.element);
		
		if(compare > 0){
			x.right = remove(x.right , element);
		}else if(compare < 0){
			x.left = remove(x.left , element);
		}else if(x.left != null && x.right != null){
			x.element = findMin(x.right).element;
			x.right = remove(x.right , x.element);
		}else{
			x = (x.left == null?x.right:x.left);
		}
		
		return balance(x);
	}
	
	//printTree用来从小到大顺序输出树的值
	//它本身也需要递归去实现
	public void printTree(){
		
		if(root == null){
			System.out.println("empty tree");
		}else{
			printTree(root);
		}
	}
	
	//中序遍历树并打印
	private void printTree(avlNode<AnyType> x){
		
		//因为每一个结点都要访问它的左右子树
		//势必出现叶子节点或其他节点没有左或右子树的情形
		//此时什么都不做，直接完成方法的调用
		//继续递归
		if(x != null){
			printTree(x.left);
			System.out.print(x.element+" ");
			printTree(x.right);
		}
	}
}
~~~

## 多路查找树

多路查找树（muitl-way search tree），其每一个结点的孩子数可以多于两个，且每一个结点处可以存储多个元素。

### 2-3树

2-3树：树的每一个结点都具有两个孩子（2结点）或三个孩子（3结点）

一个2结点包含一个元素和两个孩子（或者没有孩子），一个3结点包含两个元素和三个孩子（或没有孩子）。

这些节点包含的元素和孩子元素之间是有大小关系的，而且2-3树所有的叶子都在同一层次上：

![QQ图片20230108233335](QQ图片20230108233335.png)

### 2-3-4树

它是2-3树的扩展概念，它包括了4结点的使用，一个4结点包含三个元素及四个孩子（或者没有孩子），它们之间也是由明确的大小关系的。

### B树

B树是一种平衡的多路查找树，前面讲的2-3树和2-3-4树都是B树的特例，结点最大的孩子数目称为B树的阶，2-3树是3阶B树，2-3-4树是4阶B树。

一个m阶的B树具有如下特点：

* 如果根结点不是叶结点，则其至少有两棵子树
* 每一个非根的分支结点都有k-1个元素和k个孩子，其中[m/2]<=k<=m，每一个叶子结点n都有k-1个元素
* 所有叶子结点都位于同一层次
* 结点包含的元素和指针指向的节点是有明确的顺序关系的，结点包含下列信息：n/A0/K1/A1.../Kn/An，其中Ai是指针，Ki是关键字，Ai-1指针指向的子树中的所有结点关键字均小于Ki

由于B树每个结点可以具有比二叉树多得多的元素，所以它减少了必须访问的结点和数据块的数量，从而提高了性能。

对于含有n个关键字的B树上查找时，涉及的节点数不超过：
$$
\log_{[m/2]}{(n+1)/2} + 1
$$

### B+树

B树有一个弊端那就是遍历树的时候并不方便，每次遍历还需要单独访问元素，每单独访问一次都要对结点多次访问。

B+树是为了文件系统创造的一种B树的变形，它其实已经不是严格的树了，它的叶子结点包含全部数据信息，每一个叶子结点都保存指向下个叶子结点的指针，下面就是一棵B+树：

![QQ图片20230108235801](QQ图片20230108235801.png)

一棵m阶的B+树和B树的差异：

* 有n棵子树的结点包含有n关键字
* 所有叶子结点包含全部关键字的信息，以及指向这些记录的指针，叶子结点本身按照关键字大小链接并顺序排序
* 所有结点可以看作是索引，结点中仅含有其子树中最大或者最小的关键字

对于B+树来说，随机查找和B树是相同的，从根节点出发逐层查找。如果是需要从最小关键字进行从小到大的顺序查找，可以从最左侧的叶子结点出发遍历即可，所以它适合带有范围的查找。

## 哈希表

散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系f，使得每个关键字key对应一个存储位置f(key)，这种对应关系f称为散列函数。

采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表，对应的存储位置称为散列地址。

散列技术既是一种存储方法，也是一种查找方法。

散列技术不适用的场景：

* 一个key对应多条记录的情况
* 范围查找

当key1不等于key2，但f(key1)=f(key2)，这种现象称为冲突，key1和key2就是这个散列函数的同义词。

### 散列函数

好的散列函数需要满足的要求：1、计算简单；2、散列地址分布均匀

几种基本的散列函数：

1、直接定址法：f(key) = a * key + b，其中a和b是常数

2、数字分析法：使用关键字的一部分来计算存储位置，如果事先知道关键字的若干位分布均匀可以用这种方法

3、平方折中法：使用关键字的平方，然后抽取一部分，来计算散列地址

4、折叠法：将关键字分割为几个部分，将几部分叠加计算再取一部分作为散列地址

5、除留余数法：f(key) = key mod p (p <= m)，本方法的关键就是选择合适的p，根据经验，若散列表表长为m，通常p为小于等于表长（最好接近m）的最小质数，或者不包含小于20质因子的合数

6、随机数法：f(key) = random(key)，random是随机函数，应该是假随机函数。

应该根据不同的情况来选择合适的散列函数，这些是影响散列函数选择的因素：

* 算法效率
* 关键字长度
* 散列表大小
* 关键字的分布情况
* 查找频率

### 散列冲突

几个常用的处理散列冲突的方法：

* 开放定址法

  一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入

  f(key) = (f(key) + di) mod m ，其中m是散列表的大小，di是1到m-1的递增序列。

  例如f(key)出现冲突的时候，就取f(key)然后填入上面的公式中，计算新的f(key)，每次计算的时候di都在递增，直到找到一个f(key)是有空位的。

  上面解决冲突的方法叫线性探测法，它容易出现堆积，因此我们改进di序列，让它等于1/-1/4/-4,/9/-9，相当于双向寻找可能的空位置，不让关键字都集中在某一个区域，这种方法叫二次探测法。

  还有一种方法是随机探测法，这种方法的di是一个随机函数，相当于一个伪随机函数结果组成的序列。

* 再散列函数法

  事先准备多个散列函数，使用第一个函数计算出现冲突时，就用第二个函数计算，以此类推

* 链地址法

  将同义词存储在一个单链表中，无论有多少冲突都相当于是给单链表增加结点

* 公共溢出区法

  为所有冲突的关键字建立了一个公共的溢出区来存放。查找时如果能在基本表找到则成功，如果找不到则去溢出区寻找。当冲突数据较少时，该方法的效率还是比较高的

### 具体实现

散列表查找的时间复杂度是O1，它的平均查找长度取决于下列因素：

* 散列函数是否均匀，这决定了出现冲突的概率
* 处理冲突的方法，二次探测法在堆积问题上优于线性探测方法，链地址法处理冲突则不会产生堆积，平均查找性能更好
* 装填因子：它等于记录个数/散列表长度，它越大产生冲突的可能就越大

下面是一个用链地址法处理冲突的简单散列表实现：

~~~java
class SeparateChainingHashTable<AnyType> {
	
	//默认哈希表大小
	private static final int DAUFAULT_TABLE_SIZE = 101;
	//哈希表由一个list（实际上是linkedlist）数组组成
	private List<AnyType> [] list;
	//表示里面实际数据的个数
	private int currentSize;
	
	//空参构造
	public SeparateChainingHashTable() {
		//super();
		this(DAUFAULT_TABLE_SIZE);
	}
	
	//有参构造
	//将list初始化为linkedlist数组，大小是一个经过处理的素数
	//哈希表的最佳状态就是大小是素数时
	public SeparateChainingHashTable(int size){
		list =new LinkedList [ nextPrime( size ) ];
 
		for(int i = 0 ; i < list.length ; i++){
			list[i] = new LinkedList<>();
		}
	}
	
	//插入数据时先获取对应的linkedlist
	//再检查是否有该元素，没有就添加进去
	//同时数据总数加1
	public void insert(AnyType element){
		LinkedList<AnyType> lt = (LinkedList<AnyType>)list[myhash(element)];
		if(!lt.contains(element)){
			lt.add(element);
			currentSize++;
		}
	}
	
	//删除数据时先获取对应的linkedlist
	//再检查是否有该元素，有就删除
	//同时数据总数减1
	public void remove(AnyType element){
		LinkedList<AnyType> lt = (LinkedList<AnyType>)list[myhash(element)];
		if(lt.contains(element)){
			lt.remove(element);
			currentSize--;
		}
	}
	
	//置空：数组每项都置为null
	public void makeEmpty(){
		for(int i = 0 ; i < list.length ; i++){
			list[i] = null;
		}
	}
	
	//检查是否包含时，先获取对应的linkedlist
	//再用list的contain操作
	public boolean contains(AnyType element){
		LinkedList<AnyType> lt = (LinkedList<AnyType>)list[myhash(element)];
		return lt.contains(element);
	}
	
	//散列函数：根据输入的对象得到哈希值
	//根据其已经有的hashcode值，对表大小取余并保证其不为负数即可
	private int myhash(AnyType element){
		int x = element.hashCode();
		
		x %= list.length;
		if(x < 0){
			x += list.length;
		}
		return x;
	}
	
	//经过这个方法得到哈希表的实际大小
	//即选择一个比输入的size稍大一些的离该值最近的
	//素数值
	private int nextPrime(int size){
		if(size % 2 == 0){
			size++;
		}
		
		while(!isPrime(size)){
			size += 2;
		}
		
		return size;
	}
	
	//判断一个数是否为素数
	//这里做了一些改进，在遍历时每次递增2而不是1
	private boolean isPrime(int size){
		if(size == 2 || size == 3){
			return true;
		}
		
		if(size % 2 == 0 || size == 1){
			return false;
		}
		
		for(int i = 3;i * i <= size;i += 2){
			if(size % i == 0){
				return false;
			}
		}
		
		return true;
	}
}
~~~

### randomPool

设计randomPool结构，要求提供下面几个方法：

* 要求提供insert(key)方法，将某个key加入该结构要求不重复
* 提供delete(key)方法，将某个key移除
* 提供getRandom()方法，等概率随机返回结构中的任何一个key，要求三个方法时间复杂度O1

~~~java
	//用两个hashmap完成这个功能，如果用一个map根本不可能做到随机返回key，因为一个散列表可能未满，也可以一个桶有多个值
	//无法随机抽取，这里用两个hashmap一个以key为键数字为值，一个以数字为键key为值
	//每次插入往两个表内同时插入
	//随机抽取时只要记录size值随机产生一个数根据键去找值即可
	//删除时要把表的最后一个值填补到该位置，再删除最后一个值
	static class randomPool<anyType>{
		HashMap<Integer, anyType> map1; 
		HashMap<anyType, Integer> map2; 
		int size;
		randomPool(){
			map1 = new HashMap<>();
			map2 = new HashMap<>();
			size = 0;
		}
		
		public void insert(anyType key){
			if(!map2.containsKey(key)){
				map1.put(size, key);
				map2.put(key, size);
				size++;
			}
		}
		
		public void delete(anyType key){
			
			if(map2.containsKey(key)){
				map1.put(map2.get(key), map1.get(size - 1));
				map2.put(key, size - 1);
				map2.remove(map1.get(size - 1));
				map1.remove(size - 1);
				size--;
			}
		}
		
		public anyType getRandom(){
			if(size == 0){
				return null;
			}
			return map1.get((int)(Math.random()*size));
		}
	}
~~~







# 排序

## 分类

排序方法的稳定性定义：排序前的序列中几个关键字相同的记录的相对位置，排序后仍然保持不变就称排序方法是稳定的，否则就是不稳定的。

根据待排序的记录是否放置在内存中，可以分为内排序和外排序：

* 内排序在排序整个过程中，待排序的所有记录全部被放置在内存中
* 外排序是由于记录过多，不能同时放置在内存，整个排序过程需要在内外存之间多次交换数据才能进行

算法性能的影响因素：

* 时间复杂度
* 辅助存储空间
* 算法本身的复杂性

几种算法的各种指标对比：

![QQ图片20230114110613](QQ图片20230114110613.png)

从最好情况来看，冒泡和直接插入排序较好，如果待排序的序列总是基本有序，可以选择这两个简单的算法。

从最坏情况来看，堆排序和归并排序又胜过其他排序算法。

归并排序是唯一一个Onlogn算法中稳定的排序算法

简单选择排序的优势：比较次数多，但是移动记录的次数少

## 冒泡排序

冒泡排序是一种交换排序，它的基本思想是：两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为之。

冒泡排序的初级版，它并不算是标准的冒泡排序，它并不算两两比较相邻记录，它是最简单的交换排序，它的思路就是让每一个位置，与其之后的每一个位置都比较，如果逆序就交换，这样第一个位置一定在第一次循环后变成最小值。但是它在循环的过程中，没有对其他位置的排序产生帮助，而且还容易把数字换到更远的位置，它效率较低。

~~~java
	public static void easySort(int[] a){
		
		int t, i, j;
		for(i = 0 ; i < a.length ; i++){
			for(j = i + 1; j < a.length ; j++){
				if(a[i] < a[j]){
					t = a[j];
					a[j] = a[i];
					a[i] = t;
				}
			}
		}
	}
~~~

正宗的冒泡排序：

~~~java
	public static void bubbleSort(int[] a){
		int t, i, j;
		for(i = 0;i < a.length ; i++){
			for(j =a.length - 1 ; j > i;j--){
				if(a[j] > a[j - 1]){
					t = a[j];
					a[j] = a[j - 1];
					a[j - 1] = t;
				}
			}
		}
	}
~~~

优化后的冒泡排序，可以在整体有序后提前退出循环，提高一些性能：

~~~java
	public static void optBubbleSort(int[] a){
		int t, i, j;
		boolean flag = true;
		for(i = 0 ; i < a.length && flag;i++){
			flag = false;
			for(j = a.length - 1 ; j > i ; j--){
				if(a[j] > a[j - 1]){
					t = a[j];
					a[j] = a[j - 1];
					a[j - 1] = t;
					flag = true;
				}
			}
		}
	}
~~~

最好的情况下，整个数组是有序的，此时算法需要比较n-1次。在最糟糕的情况下，整个数组是逆序的，此时需要比较1+2+...+(n-1)次，也就是n(n-1)/2次，它的时间复杂度是On2

## 选择排序

冒泡排序中不断在交换位置，选择排序的核心思想就是减少交换次数，每次循环在剩余记录中选出最小的记录，然后放到对应的位置。

它减少了交换次数，因此获得了一定的性能提升，它的性能要优于冒泡排序，它的时间复杂度还是On2

~~~java
	//选择排序是从第一项开始，寻找除了第一项以外的最大值下标，再把下标对应的值与第一项互换
	//这样每次都从剩下的位置寻找最大值，再交换，而不是次次交换提升了效率
	//选择排序把交换数据次数降低，提升了运行效率，选择排序 》 冒泡排序
	public static void selectionSort(int[] a){
		int t, max, i, j;
		for(i = 0; i < a.length ; i++){
			max = i;
			for(j = i + 1 ; j < a.length ; j++){
				//是赋值给下标，而不是直接影响值
				if(a[max] < a[j]){
					max = j;
				}
			}
			if(max != i){
				t = a[max];
				a[max] = a[i];
				a[i] = t;
			}
		}
	}
~~~

## 插入排序

插入排序的基本思想是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数加1的有序表

这个插入并不是说每次都要进行交换，而是传递式的赋值，这样在一个大小为n的有序表中插入一个元素最多只会进行n+1次赋值

最坏的情况下，数组是逆序的，此时需要比较2+3+..+n=(n+2)(n-1)/2次，记录的移动次数是3+4+...n+1=(n+4)(n-1)/2次，时间复杂度也是On2。它的整体性能要优于选择排序和冒泡排序

~~~java
	//插入排序，原理是视第一项为有序项，从第二项开始依次使其加入序列
	//如果前方各项都比该值小，那就让各项都向后移位，直到找到正确的位置
	//将值加入该位置即可，全程都没有互换操作，有的只是简单的值传递
	//该方法性能更优越       插入排序 》 选择排序
	public static void insertSort(int[] a){
		int i,j,t;
		//循环从第二项开始，因为试第一项为有序项
		for(i = 1 ; i < a.length ; i++){
			//将a[i]的值记录下来，在后期值传递的过程中，原始的a[i]会被覆盖
			
			//这里吧第一个for循环的判断条件提上来，如果不满足就省去了赋值t和j的时间
			if(a[i - 1] < a[i]){
				t = a[i];
				//j从i-1开始向后递减查找a[j]与t的关系
				//如果t大，说明t值需要前移，前方元素需要向后移
				//在循环中通过值传递来让后一个元素等于前一个元素
				//然后更前方的元素再继续覆盖
				for(j = i - 1;a[j] < t && j >= 0;j--){
					a[j + 1] = a[j];
				}
				//在循环结束时，说明找到了a[i]的插入位置，此时所有元素都已经移动完成
				//只需在对应位置放入原来a[i]的值即可
				a[j + 1] = t;
			}
		}
	}
~~~

## 希尔排序

希尔排序(Shell Sort)是插入排序的一种，它是针对直接插入排序算法的改进。

它通过比较相距一定间隔的元素来进行，各趟比较所用的距离随着算法的进行而减小，直到只比较相邻元素的最后一趟排序为止。

如果要排序的序列是基本有序的，插入排序的效率就会很高，所谓基本有序，就是小的关键字基本在前面，大的基本在后面，像{2,1,3,6,4,7,5,8,9}就可以称为基本有序。所以希尔排序的思路就是分割待排序记录，减少待排序记录的个数，让整个序列朝基本有序的方向发展。

选择增量 gap=length/2，缩小增量以 gap = gap/2 的方式，用序列 {n/2,(n/2)/2...1} 来表示

1、初始增量第一趟 gap = length/2 = 4

整理各组至有序状态，这里面的各组之间是不连续的：

![QQ图片20230111231848](QQ图片20230111231848.png)

2、第二趟，增量缩小为 2

![QQ图片20230111232119](QQ图片20230111232119.png)

3、第三趟，增量缩小为 1,得到最终排序结果

![QQ图片20230111232210](QQ图片20230111232210.png)

~~~java
	//希尔排序，本质上是增强的插入排序
	//原理是取一个增量值，把整个序列按照增量值划分成几个部分
	//如增量值为5，则0 5 10 15 20一组，1 6 11 16 21 一组
	//把每组分别按照插入排序进行排序，这样增量值在递减过程中整个序列也趋于某种顺序
	//最后增量值为1，完成后及完成排序
	//希尔排序能把算法平均运行时间降到n的1.5次方
	public static void shellSort(int[] a){
		
		int t, j, d, i;
		//这里选取增量值为数组长的一半，且每次减少一半，增量值总会等于1，这一轮结束后循环结束
		for(d = a.length/2 ; d >= 1;d = d / 2){
			//i从d+1开始，因为属于这个序列的前一个值是1，它本身相当于有序
			//当i越界时循环结束，每次i加一
			for(i = d + 1 ; i < a.length ; i++){
				//如果满足这个表达式说明这一轮无需进行排序
				//待插入的值比前一个值小，说明它比前面的任何值都小，这自然满足要排序的目的
				//实质上这个是把第一次循环的条件提了上来，如果不满足就省去了赋值t和j的时间
				if(a[i] > a[i - d]){
					//把待插入元素值记录，以免被覆盖
					t = a[i];
					//循环开始，向前查找有没有项大于待插入元素，如果有就让整体元素向后移动
					for(j = i - d;j > 0 && t > a[j] ; j = j - d){
						a[j + d] = a[j];
					}
					//移动完毕后把待插入项放到正确的位置
					a[j + d] = t;
				}
			}
		}
	}
~~~

注意增量序列的最后一个增量值必须等于1才行。

希尔排序时间复杂度是 O(n^(1.3-2))，排序期间它的记录是跳跃式移动，所以它并不算一个稳定的排序算法

## 堆排序

堆排序是选择排序的优化，选择排序每次在对比的时候没有吧之前对比的结果记录下来，导致后一次遍历时无法复用之前的结果，造成一些重复比较。

如果可以在选择到最小记录时，根据比较结果对其他记录进行响应的调整，那整体的排序效率就会提高，这就是堆排序的思路。

下面的两个结构就是堆：

![QQ图片20230111233422](QQ图片20230111233422.png)

每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；每个结点的值都小于或者等于其左右孩子结点的值，称为小顶堆。

如果用大顶堆和小顶堆以层序遍历的方式存入数组，就是下面这样的：

![QQ图片20230111233613](QQ图片20230111233613.png)

这个结构其实就是为了堆排序做准备的。

堆排序会将待排序的序列构造成一个大顶堆，此时整个序列的最大值就是堆顶的根结点，将它与堆数组的末尾元素交换，此时末尾元素就是最大值，然后将剩余元素重新构造成一个堆，然后再取其中的最大值交换，反复执行，最后就能得到一个有序序列。

堆排序的两个重要步骤：

* 如何由无序序列构建成一个堆
* 如何在输出堆元素后，调整剩余元素成为一个新的堆

1、构造堆的过程

从非叶子结点的最后一个值开始调整，如下图的红色结点。完全二叉树有个重要性质，对于第一个非叶子节点的索引是 n/2 取整数得到的索引值，其中 n 是元素个数(前提是数组索引从 1 开始计算)。

![QQ图片20230111234908](QQ图片20230111234908.png)

索引 5 位置是第一个非叶子节点，我们从它开始逐一向前分别把每个元素作为根节点进行 shift down 操作满足最大堆的性质。

索引 5 位置进行 shift down 操作后，22 和 62 交换位置。

![QQ图片20230111234945](QQ图片20230111234945.png)

对索引 4 元素进行 shift down 操作。

以此类推，对每个节点都进行shift down 操作，和它的左右节点对比，不断的吧最小的节点和自己互换，直到满足小顶堆的标准。

2、输出堆元素后，调整剩余元素成为一个新的堆

此时相当于堆顶元素是不满足堆定义的，此时只需要仿照前面的 shift down 操作，将结点不断下移即可：

![QQ图片20230111235158](QQ图片20230111235158.png)

调整完毕的样子：

![QQ图片20230111235255](QQ图片20230111235255.png)

堆排序中需要知道的完全二叉树知识：

* 堆是一个完全二叉树，结点i的左孩子是2i+1，右结点是2i-1
* 一个结点的父节点是（i-1）/2
* 开始时从i = arr.length/2 - 1开始调整，这是最后一个叶子节点的父节点，也就是最后一个需要调整的结点

代码实现：

~~~java
	//堆排序，原理是把数组整理成一个堆，这样第一个位置的元素自然是最大值或者最小值
	//把这个最值与数组最后一个位置调换，把前n-1个元素继续整理成一个堆
	//然后继续上面的过程，堆越来越小，直到数组有序
	//它把排序的平方运行时间降到了nlogn
	public static void heapSort(int[] a){
		
		int t, i, j;
		//这个循环的作用是将初始数组整理成一个小顶堆
		//只有整理成小顶堆，然后不断把第一个元素挪到最后一个才能形成从大到小的序列
		//要整理的元素从a.length/2开始，它是需要整理的第一个元素，是非叶子节点的最右值
		//叶子节点全都不用调整，i随着运行递减，直至i为0即调整堆顶元素，结束后即完成堆排序
		//这种整理堆排序的方法是从下至上的，每次运行时它下方的元素都处于满足小顶堆特性的状态
		for(i = a.length/2 - 1 ; i >= 0 ; i--){
			//自始至终处理范围都是a.length，因为初始阶段堆的大小并不变
			adjustDown(a , i , a.length);
		}
		System.out.println("此时已经生成堆"+Arrays.toString(a));
		//System.out.println("整理完毕");
		//真正的排序开始，一共进行n-1次调整即可
		//每次都把堆顶与堆最后一个互换位置，再调整剩下元素使其满足堆的性质
		for(j = 1 ; j < a.length ; j++){
			t = a[0];
			a[0] = a[a.length - j];
			a[a.length - j] = t;
			//随着运行，堆的大小在变小，处理堆的范围在缩小
			//每次互换后只需调用一次这个方法即可，因为除了堆顶元素下方元素都已经满足了堆的要求
			adjustDown(a , 0 , a.length - j);
			System.out.println("转换移动！"+Arrays.toString(a));
		}
	}
	
	//调整堆结构的方法，第二个参数是要调整的位置，第三个参数是堆的大小
	private static void adjustDown(int[] a , int i , int len){
		
		//把要调整的元素大小用t保存起来，防止被覆盖
		int t = a[i], j;
		//循环开始，j值从2i开始，2i正好是要调整元素的左孩子，每次循环之后j要乘2
		//因为调整通常不在一层进行，上下元素互换使原元素小于左右孩子后，
		//因此改变的左右孩子可能和他自己的左右孩子不满足堆的性质，需要再次调整
		//直至j等于数组大小时，一次调整结束
		//System.out.println("我是真的在执行");
		//System.out.println("此时的数组是" + Arrays.toString(a));
		for(j = 2 * i + 1 ; j < len ; j = j * 2 + 1 ){
			//a[j + 1] < a[j]说明右兄弟的值更小，它才是要与父母结点互换的结点
			//此时把j加一这样后面两者互换之后就可以满足小顶堆的性质了
			//j = len - 1 意味着左孩子是整个堆的最后一个元素
			//此时它没有兄弟元素故不必进行下列操作了
			//System.out.println("此时的j是谁？"+j);
			if(j < len - 1 && a[j + 1] < a[j]){
				j = j + 1;
			}
			//如果t > a[j]说明原要调整的结点比孩子结点大，此时把要调整的结点赋值为孩子结点
			//同时改变i为j，记录下最后一个改变的结点位置
			//在多次循环中，因为一次互换导致的子树也不满足堆的要求
			//要不断向下传递值
			if(t > a[j]){
				a[i] = a[j];
				i = j;
			}else{
				//如果本来就满足堆的性质则无需调整
				//直接跳出循环，此时它下方的元素已经全部满足堆的性质
				//无需进行下一步循环了
				break;
			}
		}
		//运行到这里通过一系列值传递，操作的最底层和相邻层一定有两个相同元素
		//此时利用记录下来的值把正确的值赋给它
		a[i] = t;
	}
~~~

具有n个结点的完全二叉树的深度为[logn] + 1 ，所以无论是重建还是调整，总的来说，堆排序的时间复杂度是Onlogn。空间复杂度上，它只有一个用来交换的暂存单元。由于记录的交换和比较是跳跃式进行，所以它是不稳定的排序算法。

由于初始构建堆所需要的比较次数较多，因此它不适合待排序序列个数较少的情况。

下面介绍一些堆的其他应用：

### 堆与贪婪算法

堆可以方便的求最大最小值，所以它在贪婪算法中有很多应用，例如下面这个案例：

一块金条切成两半需要花费与数值相同的铜板，比如一根长度为20的金条需要20铜板。现给定一个数组[10,20,30]，数组反映了两个信息：

第一，金条长度为数组的和60，第二，要把金条切成3份，每份是10，20，30

要求输入一个数组，返回分割的最小代价（哈夫曼编码）

~~~java
	//建立一个小顶堆，将数组输入，每次从小顶堆中取出两个数，就是数组的最小的两个数
	//加起来把和再放回去，直至堆中一个数，把生成的所有和都加起来即可
	//对10,20,30，先选出10和20，合成30，再由30和30合成60，总的代价就是90
	//切割的时候反着来，先由60切成两个30，再把其中一个30切成两个一个10一个20
	public static int splitGold(int[] arr){
		PriorityQueue<Integer> heap = new PriorityQueue<>();
		for(int i = 0; i < arr.length; i++){
			heap.add(arr[i]);
		}
		
		int num;
		int sum = 0;
		while(heap.size() > 1){
			num = heap.poll() + heap.poll();
			sum += num;
			heap.add(num);
		}
		
		return sum;
	}
~~~

### 用堆取中位数

设置一个结构可以随时获得一组数据的中位数

~~~java
    //设计两个堆，一个堆代表一组数中较小部分的大顶堆，一个堆代表一组数中较大部分的小顶堆
	//两个堆的堆顶分别是较小一半的最大值和较大一半的最小值
	//中位数一定在这两个数之间
	//每次添加数的时候如果数比大顶堆的堆顶还大就放到小顶堆去
	//每次两个堆的大小差超过1之后就进行调整使堆大小平衡
	static class getMid{
		PriorityQueue<Integer> heapMaxInBefore;
		PriorityQueue<Integer> heapMinInAfter;
		
		getMid(){
			heapMaxInBefore = new PriorityQueue<Integer>(10, new BigHeap());
			heapMinInAfter = new PriorityQueue<Integer>();
		}
		
		public void add(int num){
			if(!heapMaxInBefore.isEmpty() && heapMaxInBefore.peek() < num){
				heapMinInAfter.add(num);
			}else{
				heapMaxInBefore.add(num);
			}
			balance();
		}
		
		private void balance(){
			if(heapMinInAfter.size() - heapMaxInBefore.size() > 1){
				heapMaxInBefore.add(heapMinInAfter.poll());
			}else if(heapMaxInBefore.size() - heapMinInAfter.size() > 1){
				heapMinInAfter.add(heapMaxInBefore.poll());
			}else{
				;
			}
		}
		
		public int getMidNum(){
			if(heapMinInAfter.size() > heapMaxInBefore.size()){
				return heapMinInAfter.peek();
			}else{
				return heapMaxInBefore.isEmpty()? (Integer)null : heapMaxInBefore.peek();
			}
		}
	}
	
	static class BigHeap implements Comparator<Integer>{
		@Override
		public int compare(Integer o1, Integer o2) {
			return o2 - o1;
		}
	}
~~~

## 归并排序

归并排序（Merging Sort）是利用归并的思想实现的排序算法，它把初始序列看作n个有序的子序列，每个子序列只有1个元素，不断两两归并，最后得到一个长度为n的有序序列，这种排序方法称为2路归并排序。

它就像一棵倒置的完全二叉树：

![QQ图片20230113212308](QQ图片20230113212308.png)

### 递归算法

~~~java
	//合并排序，原理是将数组分成一半，前一半和后一半再分一半
	//直至分成单个元素，将它们两两排序再合并，2个合并为4个，这样下去直至合并成原数组
	//就像是多个叶子合成二叉树的过程，这里关键就是如何将两个数组合并成一个有序数组
	//合并排序的运行时间是nlogn，运行效果比较稳定
	//但需要n+logn的空间复杂度，不用递归后这个值可以减到n
	public static void mergeSort(int[] a){
		//这里用了另一个封装的函数，因为整个过程用递归完成
		mergeSort(a, 0, a.length - 1);
	}
	
	//mergeSort的第一个参数是数组，第二个参数是排序开始的位置，第三个参数是排序结束的位置
	private static void mergeSort(int[] a , int low , int high){
		
		//基线条件是low < high，只有当两个值相等时才不会继续调用本函数
		if(low < high){
			//计算mid，他是前后排序的分界线
			int mid = (low + high) / 2; 
			
			//将从low到mid排序
			mergeSort(a, low, mid);
			//将mid+1到high排序
			mergeSort(a, mid + 1, high);
			//最后把两者合并
			merge(a, low, mid, high);
		}
		
	}
	
	//合并函数，第一个参数是数组，后三个参数分别指示了待合并数组的位置
	//分别是low到mid和mid+1到high
	private static void merge(int[] a , int low , int mid ,int high){
		
		int i, j, k;
		//新建一个数组b，接下来的合并中，需要从这个数组中取值更改数组a中的值
		int[] b = new int[a.length];
		//把要合并的部分的b和a相等
		for(i = low ; i <= high ; i++){
			b[i] = a[i];
		}
		//循环开始，i和j分别是两个要排序数组的循环起点，k是一个指示a数组位置的变量，表示修改a值的位置
		//当两个待排序部分有一个已经遍历完成时，退出循环
		//最后每次把k加一
		for(i = low , j = mid + 1 , k = low ; i <= mid && j <= high ; k++){
			//两个待排序部分相互比较，较大的那个拿到a数组中，并把原来数的位置加1
			//以便下次继续比较
			if(b[i] >= b[j]){
				a[k] = b[i++];
			}else{
				a[k] = b[j++];
			}
		}
		//运行到这里意味着待排序部分的其中一个所有值都拿到了a数组，另一个还有部分值没有拿到
		//下面的两个循环就是哪个数组还没有运行完就继续把剩余的变量都依次拿到a数组
		while(i <= mid){
			a[k++] = b[i++];
		}
		while(j <= high){
			a[k++] = b[j++];
		}
	}
~~~

每次归并时都要将数组扫描一遍，耗费On时间，根据完全二叉树的深度可知，整个归并排序需要进行[logn]次，因此总的时间复杂度是Onlogn，而且这是归并排序中最好、最坏、平均的时间性能。

由于归并排序在归并过程中需要创建与原始序列相同大小的辅助数组，以及递归时深度为logn的栈空间，所以空间复杂度是On+logn

归并存在两两比较，但是不存在跳跃，因此归并排序是一种稳定的排序算法。

在实际解决问题时，可以用多定义一个冗余变量的方式来使程序的可读性更好，在上面的归并排序代码中，merge方法有四个参数，下面这个改进版可读性更好，它明确定义了合并时两段区间的起始和末尾：

~~~java
	//归并排序
	public static void mergeSort(int[] a){
		mergeSort(a, 0, a.length-1);
	}
	
	private static void mergeSort(int[] a, int begin, int end){
		if(begin < end){
			int mid = begin + (end - begin)/2;
			mergeSort(a, begin, mid);
			mergeSort(a, mid + 1, end);
			merge(a, begin, mid, mid + 1, end);
		}
	}
	
	private static void merge(int[] a, int begin_1, int end_1, int begin_2, int end_2){
		int i = begin_1;
		int[] b = new int[a.length];
		for(int j = 0; j < b.length; j++){
			b[j] = a[j];
		}
		while(begin_1 <= end_1 && begin_2 <= end_2){
			if(b[begin_1] <= b[begin_2]){
				a[i++] = b[begin_1++];
			}else{
				a[i++] = b[begin_2++];
			}
		}
		
		while(begin_1 <= end_1){
			a[i++] = b[begin_1++];
		}
		
		while(begin_2 <= end_2){
			a[i++] = b[begin_2++];
		}
		
	}
~~~

### 非递归算法

递归算法容易理解，但是会造成空间上的消耗，因此可以想办法将递归转换为迭代。

非递归算法其实就是建立了一个大小相同的数组作为辅助数组，每次归并的时候将元素从一个数组转移到另一个数组。

~~~java
	//非递归的合并排序，将递归的算法空间复杂度进一步降低
	//这种方法创建了一个与a同大小的数组b，刚开始将大小为1的相邻有序序列重新排序
	//从a装入b中，然后取大小为2的相邻有序序列再重新排序从b装入a中
	//这样直到完成排序
	public static void optMergeSort(int[] a){
		//chg就是这个起中转作用的数组
		int[] chg = new int[a.length];
		//k是每次排序的有序序列大小，从1开始每次转换排序k都翻倍
		int k = 1;
		//循环的结束条件是当k大小超出数组大小，当k本身等于数组大小也可以
		while(k < a.length){
			//将a中大小为k的相邻有序序列重新排序，比如a中1,2,3,4，b中就是2,1,4,3
			//这就是k为1的状况
			mergePass(a, chg, k);
			//k翻倍，再将数组chg中的内容弄到a中来
			//k越界也没有关系，在方法内部不会执行任何操作
			k = k * 2;
			mergePass(chg, a, k);
			k = k * 2;
		}
	}
	
	//这个方法代表将a中将大小为k的相邻序列移动到b中，这里的移动有三种基本情况
	private static void mergePass(int[] a, int[] b, int k){
		int i = 0;
		//第一种情况，处理成对的序列
		while(i + 2 * k <= a.length){
			//两组重新排序后将a的值放入b中，每次i的值都加2k，再一次执行相同的操作
			merge(a, b, i, i+k-1, i+2*k-1);
			i = i + 2*k;
		}
		
		//第二种情况，在成对的处理完成之后，还剩一组不足一对的，类似0000 0000 0000 00
		//此时merge处理的两组是不等长的
		if(i + k < a.length){
			merge(a, b, i, i+k-1, a.length - 1);
			//最后一种情况，剩下的连半对都不到，类似0000 0000 00
			//此时直接把对应值复制过去
			//这个过程还是要加判断条件，以免越界的情况
		}else{
			for(int j = i ; j < a.length ; j++){
				b[j] = a[j];
			}
		}
	}
	
	//这个merge比之前多了一个数组参数，不需再new一个和初始化数组了
	private static void merge(int[] b, int[] a, int low , int mid ,int high){
		int i, j, k;

		for(i = low , j = mid + 1 , k = low ; i <= mid && j <= high ; k++){

			if(b[i] >= b[j]){
				a[k] = b[i++];
			}else{
				a[k] = b[j++];
			}
		}

		while(i <= mid){
			a[k++] = b[i++];
		}
		while(j <= high){
			a[k++] = b[j++];
		}
	}
~~~

非归并算法的额外空间复杂度降低到了On

## 快速排序

### 切分数组

给定一个数组arr和一个数num，把小于等于num的数放在数组左边 大于num的数放在数组右边：

~~~java
	//----------------------------------------------------------------
	//给定一个数组arr和一个数num，把小于等于num的数放在数组左边 大于num的数放在数组右边
	//遍历数组，j为一个小于等于区域的分界线
	//如果i位置的数比num小或等于num，就把它和小于等于区域的下一个数交换，再让j扩大一位
	//被交换过去的数总是大数，而交换回来的一定是小数，这样直到最后，所有的小数都被交换回来了
	public static void splitArr(int[] arr, int num) {
		int i = 0, j = -1;
		while (i < arr.length) {
			if (arr[i] <= num) {
				swap(arr, j + 1, i);
				j++;
			}
			i++;
		}
	}
~~~

### 荷兰国旗问题

荷兰国旗问题： 给定一个数组arr和一个数num，把小于num的数放在数组左边，等于num的数放在数组中间，大于num的数放在数组右边

~~~java
	//设置一个小于num区域，一个大于num区域
	//遍历数组，每次如果i位置的数小于num，就把它和最小区域的下一个数交换，同时最小区域扩大一位
	//如果i位置的数等于num，就直接遍历下一个数
	//如果i位置的数大于num，就把它和大区域的最后位置前一个位置互换，同时大区域扩大一位
	//由于被互换回来的数没有访问过，故此时不更新i直接访问原地的值
	public static void dutchFlag(int[] arr, int num) {
		int i = 0, begin = -1, end = arr.length;
		while (i < end) {
			if (arr[i] < num) {
				swap(arr, i, begin + 1);
				i++;
				begin++;
			} else if (arr[i] > num) {
				swap(arr, i, end - 1);
				end--;
			} else {
				i++;
			}
		}
	}
~~~

### 经典快速排序

快速排序基本思想：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。

希尔排序是直接插入排序的升级，它们都属于插入排序类；

堆排序是简单选择排序的升级，它们都属于选择排序类；

快速排序是冒泡排序的升级，它们都属于交换排序类。快速排序也是通过不断比较和移动交换来实现的，相比冒泡排序，它增大了记录的比较和移动的距离，可以让关键字较大的记录直接移动到数组的后面，较小的记录直接移动到前面，从而减少了总的比较和交换次数。

快速排序是一种比较快速的排序算法，它的平均运行时间是 O(nlogn)，之所以特别快是由于非常精练和高度优化的内部循环，最坏的情形性能为 O(n^2)。像归并一样，快速排序也是一种分治的递归算法。从空间性能上看，快速排序只需要一个元素的辅助空间，但快速排序需要一个栈空间来实现递归，空间复杂度也为O(logn)

快速排序是一种不稳定的排序算法。

在一个数组中选择一个基点，比如第一个位置的 4，然后把4挪到正确位置，使得之前的子数组中数据小于 4，之后的子数组中数据大于 4，然后逐渐递归下去完成整个排序：

![QQ图片20230113222342](QQ图片20230113222342.png)

~~~java
	//快速排序，原理是设置一个关键元素，从后往前寻找比关键元素小的值与前面的值交换
	//再从前往后找比关键元素大的值与后面的值交换
	//当两边交替寻找到两个指针相等时，将这个位置设置为关键元素
	//将分割的两部分再通过同样的算法寻找，直到寻找的范围缩小为1个
	//当要排序的数组小于等于7时建议直接使用插入排序，这样效率更高
	public static void quickSort(int[] a){
		//传递给一个递归的方法
		quickSort(a, 0, a.length - 1);
	}
	
	//递归方法
	private static void quickSort(int[] a, int low, int high){
		//当low与high相等时，什么都不做
		if(low < high){

			//用partition方法切割数组，并取到关键元素的位置pivotkey
			int pivotkey = partition(a, low, high);
			//将数组按关键元素位置分别进行排序
			quickSort(a, low, pivotkey - 1);
			
			//这里对语句做了一个简单的优化，让low重新赋值了一下并把判断由if改为了while
			//让一部分循环代替递归工作，一定程度上降低了栈的深度
			quickSort(a, pivotkey + 1, high);
			// low = pivotkey + 1;
			System.out.println(pivotkey + " " + low + " " + high);
		}
	}
	
	//切割函数
	private static int partition(int[] a, int low, int high){
		
		//选取头中尾三个数的中间值作为low位置的值，它作为关键值划分效率比直接选low的值高
		int t, mid = (low + high)/2;
		if(a[low] > a[high]){
			t = a[low];
			a[low] = a[high];
			a[high] = t;
		}
		if(a[mid] > a[high]){
			t = a[mid];
			a[mid] = a[high];
			a[high] = t;
		}
		if(a[mid] > a[low]){
			t = a[mid];
			a[mid] = a[low];
			a[low] = t;
		}
		
		//设置第一个元素为关键元素，这里的pivotkey是元素值不是位置
		int pivotkey = a[low];
		//当low=high时退出循环
		while(low < high){
			//当后面有元素大时退出循环，并把大元素赋值给low的位置，也就是放到前面
			//这里必须要加low和high的判断关系，因为这两个值是不断变化的
			//即使low已经与high相等，后面的赋值语句也是自己给自己赋值，不会影响结果
			while(low < high && a[high] <= pivotkey){
				high--;
			}
			a[low] = a[high];
			//当前面有元素小时退出循环，并把小元素赋值给high的位置，也就是放到后面
			while(low < high && a[low] >= pivotkey){
				low++;
			}
			a[high] = a[low];
		}
		//最后low与high相等退出了循环，把pivotkey的值放到这个位置，切割排序完成
		a[low] = pivotkey;
		//最后返回pivotkey的位置，为切割子序列做准备
		return low;
	}
~~~

在快速排序中，枢轴（pivot）的选择是很重要的，如果枢轴是整个序列的中间位置，那么就可以将序列分为小数集合和大数集合。如果pivot总是固定选择第一个关键字，那么对特定排序的序列来说，就非常不合理。

常见的方法有以下几种：

* 随机取low到high之间的树rnd，然后取rnd位置对应的关键字作为pivot。它的总体情况要好于取第一个位置。
* 取low、high、mid之间的中间值作为pivot，这就是三数取中法，它一定不会取到最大或者最小的数，效果较好
* 九数取中，是三数取中的进化版，取九个数中最中间的数



### 优化版

在下面的优化版算法中，用荷兰国旗的算法修改partition部分，这样切分后的数组就成了三部分，因此分区的指针也变成了两个。

在每次排序之前进行一次随机交换，然后取第一位为枢轴，相当于实现了随机快排：

~~~java
	//-------------------------------------------------------
	//随机快排:用荷兰国旗的算法修改partition部分
	//只是将数组划分成了三部分，且设置了前后两个指针来运作
	
	//随机快排在每次排序之前都要把最后一个位置和之前的某个位置交换
	//这样一来作为关键元素的值就不一定了，此时快速排序真正实现了运行时间的长期期望O（nlogn）
	public static void quickSort_c(int[] arr){
		quickSort_c(arr, 0, arr.length-1);
	}
				
	private static void quickSort_c(int[] arr, int i, int j){
		if(i < j){
			swap(arr, (int)Math.random()*(j - i + 1) + i, j);
			//通过partition获得划分的分界点
			int[] key = partition_c(arr, i, j);
			//处理分界点前后的数组
			quickSort_c(arr, key[0]+1, j);
			quickSort_c(arr, 0, key[1]-1);
		}
	}
			
	//将数组划分成了三部分，且设置了前后两个指针来运作
	private static int[] partition_c(int[] arr, int i, int j){
		int begin = i - 1;
		//这里因为num值是arr[j]，所以实际上操作区域就减了一位，从j开始
		//之所以设置arr[j]为关键值，是因为j是始终不动的，自然也就不在需要开辟空间来完成这个工作
		int end = j;
		while(i < end){
			if(arr[i] < arr[j]){
				swap(arr, i, begin+1);
				i++;
				begin++;
			}else if(arr[i] > arr[j]){
				swap(arr, i, end-1);
				end--;
			}else{
				i++;
			}
		}
			
		//最后还要交换end和j，因为此时end位置是大于区域的首位，j是游离在外的num值
		//此时交换结束之后，等于区域的结束点就在end区域了，这样num值就加入了等于区域
		swap(arr, end, j);
		//最后返回了与num相等区的开始和结束
		//此时num区的结束在end位置
		return new int[]{begin + 1, end};
	}	
~~~

## 桶排序

桶排序是一种特殊的排序算法，它使用较大的额外空间，而且对输入的数据有要求。如果整个数组的最大值和最小值相差不大的话，它的算法复杂度要低于快速排序：

~~~java
	//桶排序
	//先遍历数组找到数组的最大值和最小值，并建立一个大小为max - min + 1的数组，这个数组与原数组可能出现的数一一对应
	//再次遍历原数组，把新建数组中各位置更新为对应数字出现的次数
	//最后根据各数出现次数往原数组中填数
	public static void BucketSort(int[] arr){
		
		int max = Integer.MIN_VALUE, min = Integer.MAX_VALUE;
		//寻找最小值和最大值
		for(int i = 0; i < arr.length; i++){
			max = arr[i] > max?arr[i]:max;
			min = arr[i] < min?arr[i]:min;
		}
		//建立数组b，b与a中可能出现的所有数都一一对应
		int[] b = new int[max - min + 1];
		for(int i = 0; i < arr.length; i++){
			b[arr[i] - min]++;
		}
		//最后把原来的数组赋予成排序后的值
		int j = 0;
		for(int i = 0; i < arr.length; i++){
			//b数组从0开始，只要等于零就移动到下一个
			while(b[j] == 0){
				j++;
			}
			//直到b数组某个数不为0，把原数组对应的数放回去
			arr[i] = j + min;
			//同时该数的个数减一
			b[j]--;
		}
	}
~~~

# 递归

递归函数的必要组成部分：

- 基线条件base case：函数不再递归调用自己的条件
- 递归条件recursive case：函数递归调用自己的条件

分而治之(divide and conquer，D&C)：一种递归式问题解决思路，它可以逐步缩小问题的规模并解决。分而治之的使用步骤：

- 找出简单的基线条件
- 确定如何缩小问题的规模，使其符合基线条件

归纳证明经常与分而治之协同发挥作用。

快速排序就是一种分而治之算法，按照分而治之的使用步骤：

- 找出基线条件，就是不需要排序的数组，空数组或者只包含一个元素的数组
- 缩小问题规模的过程：从数组中选择一个元素，这个元素被称为基准值，遍历数组，找出比基准值大的元素和比它小的元素，这个过程叫分区。然后对这两个子数组再分别使用排序算法排好序，最后只需要左边数组+基准值+右边数组就是一个排好序的数组了。

## 汉诺塔问题

汉诺塔的游戏是在一块铜板装置上，有三根杆(编号A、B、C)，在A杆自下而上、由大到小按顺序放置64个金盘。游戏的目标：把A杆上的金盘全部移到C杆上，并仍保持原有顺序叠好。操作规则：每次只能移动一个盘子，并且在移动过程中三根杆上都始终保持大盘在下，小盘在上，操作过程中盘子可以置于A、B、C任一杆上。

![QQ图片20230114183429](QQ图片20230114183429.png)

设移动盘子数为n，为了将这n个盘子从A杆移动到C杆，可以做以下三步：

* 以C盘为中介，从A杆将1至n-1号盘移至B杆；
* 将A杆中剩下的第n号盘移至C杆；
* 以A杆为中介；从B杆将1至n-1号盘移至C杆。

第一步和第三步又可以继续分为n-2个盘的移动问题。

下面用代码解决汉诺塔问题，输入n，从上往下号码分别是1-n，展示从第一个杆移动到最后一个杆的过程，要求不能直接从一端移动到另一端，只能先移动到中间再移动

~~~java
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		hanNuo(3);
	}

	//递归，把n个数从一端移动到另一端，拆解成n-1个数的移动和最后一个数的移动
	public static void hanNuo(int num) {
		hanNuo(num, "left", "right", "mid");
	}
	
	public static void hanNuo(int num, String start, String end, String mid) {
		if(num == 1) {
			System.out.println("take " + num + " from " + start + " to " + mid);
			System.out.println("take " + num + " from " + mid + " to " + end);
		}else {
			hanNuo(num - 1, start, end, mid);
			System.out.println("take " + num + " from " + start + " to " + mid);
			hanNuo(num - 1, end, start, mid);
			System.out.println("take " + num + " from " + mid + " to " + end);
			hanNuo(num - 1, start, end, mid);
		}
	}
~~~

## 折痕问题

输入一个参数N，给出纸条从下边到上边连续对折N次从上到下所有折痕的方向，例如N=1，down，N=2，down down up

~~~java
	//模拟树的中序遍历，用布尔变量去控制左右子树，设置两个值，一个是层数一个是当前层数，来模拟树
	//这个递归函数会回到本方法3次，在回到方法第二次打印一个值，与中序遍历相同
	//num是树的深度，i指示走到了第几层，用这种方式去模拟一棵树
	public static void printAllFolds_a(int num){
		printAllFolds_a(1, num ,true);
	}

	private static void printAllFolds_a(int i, int num, boolean b) {
		if(i > num){
			return;
		}
		
		printAllFolds_a(i + 1, num, true);
		System.out.print((b?"down":"up") + " ");
		printAllFolds_a(i + 1, num, false);
	}
~~~





# 其他补充算法

## 并查集

实现一个并查集UnionFindSet，提供两个功能，合并两个元素所在的集合，查询两个元素是否在一个集合中，要求平均时间复杂度均为O1

~~~java
	//这个结构有两个map，一个map装的是结点和它的父节点，另一个map装的是以当前结点为头的集合的总结点个数
	//用map的方式去模拟集合
	//初始化时传入一个list，将list的每个元素单独成一个集合，也就是说在map中每个节点以自己为头结点
	//在Nummap中每个节点对应的集合数是1
	//每次合并两个元素所在的集合，就是比较哪个集合更大，让大集合头结点作为小集合的头结点
	//也就算是合并成功
	//每次判断两个元素是不是在一个集合中时，只需要检查两个元素的头结点是不是一个，是说明是一个集合
	//每次检查一个元素的头结点时要反复取map中的值，这个过程中经过的所有节点在检查完成后都直接以头结点为父节点
	//这样也就缩短了下次检查的时间
	static class UnionFindSet<anyType>{
		HashMap<anyType, anyType> map;
		HashMap<anyType, Integer> Nummap;
		
		UnionFindSet(List<anyType> list){
			map = new HashMap<>();
			Nummap = new HashMap<>();
			for (anyType node : list) {
				map.put(node, node);
				Nummap.put(node, 1);
			}
		}
		
		public boolean isSameSet(anyType node1, anyType node2){
			if(!map.containsKey(node1) || !map.containsKey(node2)){
				throw new NoSuchElementException();
			}
			
			return headNode(node1) == headNode(node2);
			
		}
		
		private anyType headNode(anyType node){
			anyType father = map.get(node);
			if(father != node){
				father = headNode(father);
			}
			map.put(node, father);
			return father;
		}
		
		public void mergeNode(anyType node1, anyType node2){
			if(headNode(node1) != headNode(node2)){
				int num1 = Nummap.get(headNode(node1));
				int num2 = Nummap.get(headNode(node2));
				if(num1 > num2){
					map.put(headNode(node2), headNode(node1));
					Nummap.put(headNode(node1), num1 + num2);
				}else{
					map.put(headNode(node1), headNode(node2));
					Nummap.put(headNode(node2), num1 + num2);
				}
					
			}
		}
	}
~~~

## Trie树

实现一颗trie树：

* 实现insert方法添加字符串，实现search方法查某个字符串添加过多少次
* 实现delete方法删除一个字符串，实现prefixNumber方法查看多少字符串以输入值为前缀

要求所有方法的复杂度为On

~~~java
	//每个节点有两个数字域和一个数组
	//当加入abc时，生成一个结点，它的数组0号位置生成一个新的结点，然后新节点的数组1号位置生成新节点
	//新节点数组的2号位置继续生成新节点，也就是说trie树不在结点记录信息，而是在通往另一个结点的路径上
	//结点的times记录有多少字符串从这里经过，当查有多少字符串以abc为前缀时，只要找到c对应的下一个结点
	//该点times就是该数量
	//结点的end记录有多少字符串以此为结尾，当查abc在该结构中出现几次时，只要检查c下一个结点的end即可
	//删除结点就是两个域在遍历中减小的过程，如果其中减小到0那么就放弃余下所有点
	
	//trie树巧妙的把数据存在各结点的路径上，大大压缩了字符串的储存空间
	static class Trie{
		
		TireNode root;
		
		class TireNode{
			int end;
			int times;
			TireNode[] next;
			TireNode(){
				next = new TireNode[26];
			}
		}
		
		public Trie(){
			root = new TireNode();
			root.end = 0;
			root.times = 0;
		}
		
		public void insert(String str){
			if(str == null){
				return;
			}
			char[] charArray = str.toCharArray();
			TireNode currentNode = root;
			int index;
			for(int i = 0; i < charArray.length; i++){
				index = charArray[i] - 'a';
				if(currentNode.next[index] == null){
					currentNode.next[index] = new TireNode();
				}
				currentNode = currentNode.next[index];
				currentNode.times++;
			}
			currentNode.end++;
		}
		
		public int search(String str){
			if(str == null){
				return (Integer)null;
			}
			
			char[] charArray = str.toCharArray();
			TireNode currentNode = root;
			int index;
			for(int i = 0; i < charArray.length; i++){
				index = charArray[i] - 'a';
				if(currentNode.next[index] == null){
					return 0;
				}
				currentNode = currentNode.next[index];
			}
			return currentNode.end;
		}
		
		public void delete(String str){
			if(search(str) > 0){
				char[] charArray = str.toCharArray();
				TireNode currentNode = root;
				int index;
				for(int i = 0; i < charArray.length; i++){
					index = charArray[i] - 'a';
					if(currentNode.next[index].times == 1){
						currentNode.next = null;
						return;
					}
					currentNode = currentNode.next[index];
					currentNode.times--;
				}
				currentNode.end--;
			}
		}
		
		public int prefixNumber(String str){
			
			if(str == null){
				return 0;
			}
			char[] charArray = str.toCharArray();
			TireNode currentNode = root;
			int index;
			for(int i = 0; i < charArray.length; i++){
				index = charArray[i] - 'a';
				if(currentNode.next[index] == null){
					return 0;
				}
				currentNode = currentNode.next[index];
			}
			return currentNode.times;
		}
	}
~~~

## BFPRT算法

BFPRT算法：在一个数组中找到第k个小的数，要求时间复杂度ON

~~~java
	//任意选择一个数作为key，进行荷兰国旗分数组，如果k正好落在区间内就说明找到了该数，否则递归左边或者右边
	
	//也可以先用getNum方法先求key，这个方法中将建立一个是原数组五分之一大小的新数组，这个数组每个数都是5个数的中位数组成
	//最后又递归调用BFPRT求该数组的中位数，需要注意的是此时BFPRT一定要给出start = end 时的条件
	//否则会无限递归
	public static int BFPRT(int[] arr, int k){
		if(arr == null || arr.length < k){
			throw new RuntimeException("数组长度不合法");
		}
		return BFPRT(arr, k, 0, arr.length - 1);
	}
	
	private static int BFPRT(int[] arr, int k, int start, int end){
		//swap(arr, start, start + (int)(Math.random() * (end - start)));
		if(start == end){
			return arr[start];
		}
		int num = getNum(arr, start, end);
		int[] flag = heLan(arr, num, start, end);
		//这里不用检查start和end的关系，在调用函数入参时就已经保证了，
		//如果后两个return越界，那么前面的条件也应该满足，应该走的是第一个return
		//所以不会出现越界的情况
		if(flag[0] + 1 <= k && flag[1] + 1 >= k){
			return arr[flag[0]];
		}else if(k < flag[0] + 1){
			return BFPRT(arr, k, start, flag[0] - 1);
		}else{
			return BFPRT(arr, k, flag[1] + 1, end);
		}
	}
	
	private static int[] heLan(int[] arr, int key, int start, int end){
		int small = start - 1, k = start;
		int big = end + 1;
		while(k < big){
			if(arr[k] > key){
				swap(arr, k, big - 1);
				big--;
			}else if(arr[k] < key){
				swap(arr, small + 1, k);
				k++;
				small++;
			}else{
				k++;
			}
		}
		//这里的small+1和big-1一定能唯一的确定至少一个数的区间，因为key就在该数组中，相当于等于区至少有一个数
		return new int[]{small + 1, big - 1};
	}
	
	private static void swap(int[] arr, int start, int end){
		int k = arr[start];
		arr[start] = arr[end];
		arr[end] = k;
	}
	
	private static int getNum(int[] arr, int start, int end){
		int length = end - start + 1;
		int offset = length % 5 == 0 ? 0 : 1;
		int[] numArray = new int[length / 5 + offset];
		for(int i = 0; i < numArray.length; i++){
			int j = start + i * 5;
			int k = start + (i + 1) * 5;
			numArray[i] = getMid(arr, j, Math.min(k, end));
		}
		return BFPRT(numArray, numArray.length/2);
	}
	
	private static int getMid(int[] arr, int start, int end){
		easySort(arr, start, end);
		int length = end - start + 1;
		int mid = start + (length % 2 == 0 ? (length/2 - 1) : (length/2));
		return arr[mid];
	}
	
	private static void easySort(int[] arr, int start, int end){
		for(int i = start; i <= end; i++){
			for(int j = i - 1; j >= 0 && arr[j] > arr[j + 1]; j--){
				swap(arr, j + 1, j);
			}
		}
	}
~~~

## LRU

设计可以变更的缓存结构

设计一种缓存结构，构造时确定大小k，两个功能put(key, value)和get(key)

要求set和get时间复杂度为O1，当某个key的put和get发生就认定这个key记录成了最常用的

当缓存的大小超过k时，移除最不常使用的记录

~~~java
//这种缓存结构内部维护着两个hashMap和一个双向链表
//hashMap的键是key，值是value组成的node，这个node就是双向链表的一个结点，另一个hashmap是相反的
//为了互相能够找到所以构造了两个hashmap
//每次存值时如果不存在就存入两个hashmap中，同时将该节点放到双向链表头部，同时判断是否越界，如果越界就处理掉尾结点
//并把要删除的尾结点返回出来，在两个map中删掉，保证两个map和链表数据一致
//如果存在这个结点，就将该节点移动到双向链表头部
class twoNode{
	int val;
	twoNode pre;
	twoNode next;
	public twoNode(int val) {
		super();
		this.val = val;
	}
}

class twoLinkedList{
	twoNode head;
	twoNode tail;
	int capacity;
	int nowSize;
	public twoLinkedList(int capacity) {
		super();
		this.capacity = capacity;
		nowSize = 0;
	}
	
	public void haveNodeUp(twoNode node){
		if(head == node){
			return;
		}else if(node == tail){
			twoNode willmoveNode = tail;
			twoNode preNode = tail.pre;
			tail.pre = null;
			preNode.next = null;
			tail = preNode;
			moveTohead(willmoveNode);
		}else{
			twoNode preNode = node.pre;
			twoNode nextNode = node.next;
			preNode.next = nextNode;
			nextNode.pre = preNode;
			node.pre = null;
			node.next = null;
			moveTohead(node);
		}
	}
	public twoNode noNodeUp(twoNode node){
		if(head == null){
			head = tail = node;
		}else{
			moveTohead(node);
		}
		twoNode willDelNode = null;
		if(nowSize < capacity){
			nowSize++;
		}else{
			willDelNode = tail;
			twoNode preNode = tail.pre;
			tail.pre = null;
			preNode.next = null;
			tail = preNode;
		}
		
		return willDelNode;
	}
	
	public void moveTohead(twoNode node){
		node.next = head;
		head.pre = node;
		head = node;
		head.pre = null;
	}
}

class Cache{
	HashMap<Integer, twoNode> map1;
	HashMap<twoNode, Integer> map2;
	twoLinkedList list;
	int capacity;
	public Cache(int capacity){
		this.capacity = capacity;
		map1 = new HashMap<Integer, twoNode>();
		map2 = new HashMap<twoNode, Integer>();
		list = new twoLinkedList(capacity);
	}
	
	public void put(int key, int value){
		
		if(map1.containsKey(key)){
			map1.get(key).val = value;
			list.haveNodeUp(map1.get(key));
		}else{
			twoNode node = new twoNode(value);
			map1.put(key, node);
			map2.put(node, key);
			twoNode willDelNode = list.noNodeUp(node);
			if(willDelNode != null){
				int delkey = map2.get(willDelNode);
				map2.remove(willDelNode);
				map1.remove(delkey);
			}
		}
	}
	
	public int get(int key){
		if(map1.containsKey(key)){
			list.haveNodeUp(map1.get(key));
			return map1.get(key).val;
		}else{
			throw new RuntimeException("没有这个元素或者已经失效");
		}
	}
}
~~~